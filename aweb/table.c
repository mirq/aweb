/**********************************************************************
 *
 * This file is part of the AWeb-II distribution
 *
 * Copyright (C) 2002 Yvon Rozijn
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the AWeb Public License as included in this
 * distribution.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * AWeb Public License for more details.
 *
 **********************************************************************/

/* table.c - AWeb html document table element object */

#include "aweb.h"
#include "table.h"
#include "body.h"
#include "docprivate.h"
#include "frame.h"
#include "copy.h"

#include "stdio.h"

#include <proto/graphics.h>
#include <proto/utility.h>

#include "libraries/awebclib.h"
/*------------------------------------------------------------------------*/

struct Table
{  struct Element elt;
   void *frame;
   void *pool;                /* Memory pool */
   void *win;                 /* Current window */
   void *parent;
   LIST(Tabrow) rows;         /* Rows in this table */
   short currow;              /* Current row number */
   short rowgroupnr;          /* Current row group id (not consecutive!) */
   short rghalign,rgvalign;   /* Current row group align defaults */
   LIST(Tabrow) tfoot;        /* Rows in <TFOOT> while building table */
   short footrow;             /* Saved row number when building TFOOT */
   LIST(Coldef) coldefs;      /* Column definitions */
   short colgroupnr;          /* Current column group id (not consecutive!) */
   short nrcols;              /* Number of columns */
   short realcols;            /* Number of real columns */
   struct Tabcol *cols;       /* Array of (nrcols) columns */
   short colssize;            /* Size of cols array */
   long minw,maxw;            /* Minimum and maxinum widths of complete table */
   short border;              /* Outer border thickness */
   UWORD tabframe;            /* Outer border frame type */
   short bortop,borbottom,borleft,borright;  /* Borders for each side */
   UWORD rules;               /* Rules type */
   long nvrules;              /* total number of vertical rules in table */
   long nhrules;              /* total number of horizontal rules in table */
   short spacing;             /* Cell spacing. Cell borders are included in spacing. */
   short padding;             /* Cell padding */
   short width;               /* Suggested table width */
   struct Aobject *caption;   /* Body object for caption */
   long capminw,capmaxw;      /* Widths of caption after measure */
   struct Aobject *curbody;   /* Current body or NULL */
   ULONG flags;
   void *bgimage;             /* Common background image */
   struct Aobject *bgalign;   /* object to align image to */
   struct Colorinfo *bgcolor,*bordercolor,*borderdark,*borderlight;
                              /* Common colours */
   long incrementaly;         /* Y position where last layout begun */
   UWORD capstate;           /* "row state" for caption */
};

#define TABF_PIXELS        0x00000001  /* Width is in pixels, otherwise percentage */
#define TABF_CAPBOTTOM     0x00000002  /* Caption is at bottom, otherwise at top */
#define TABF_OPENROW       0x00000004  /* We got an open row. Else currow is last used */
#define TABF_OPENCELL      0x00000008  /* We got an open cell. */
#define TABF_OPENCAPTION   0x00000010  /* We got an open caption */
#define TABF_NOBACKGROUND  0x00000020  /* No backgrounds */
#define TABF_TFOOT         0x00000040  /* Currently defining <TFOOT> */
#define TABF_RGVALIGN      0x00000080  /* Row group valign was explicitly set */
#define TABF_INCREMENTAL   0x00000100  /* Incremental display is possible */
#define TABF_COMPLETE      0x00000200  /* Definition is complete */
#define TABF_LAYEDOUT      0x00000400  /* Table is layed out */
#define TABF_BBLAYEDOUT    0x00000800  /* Bottom border is added */

struct Coldef                 /* A <COL> definition */
{  NODE(Coldef);
   short groupnr;             /* ID of group this column belongs to */
   short swidth;              /* Suggested width */
   UWORD swtype;             /* Suggested width type */
   short halign,valign;       /* Column level alignments. */
   UWORD flags;
};

#define CDF_GENERATED      0x0001   /* Column generated by COLGROUP */
#define CDF_HALIGN         0x0002   /* halign was explicitly set */
#define CDF_FIRSTCOL       0x0004   /* First column of a group */
#define CDF_LASTCOL        0x0008   /* Last column of a group */

struct Tabrow
{  NODE(Tabrow);
   short rownr;               /* This row's id nr starting with 1 */
   short groupnr;             /* ID of group this row belongs to */
   LIST(Tabcell) cells;       /* Cells in this row */
   short nrcells;             /* Max cell number in this row */
   long y;                    /* Row position within table (ex outer spacing) */
   long height;               /* Pixel height of largest cell (spacing excluded) */
   short halign,valign;       /* Row level alignments */
   long baseline;             /* Max baseline height for all cells */
   void *bgimage;             /* Common background image */
   struct Aobject * bgalign;  /* Object to align background to */
   struct Colorinfo *bgcolor,*bordercolor,*borderdark,*borderlight;
                              /* Common colours */
   UWORD flags;
   UWORD state;              /* Used in incremental display, see below */
};

#define TABRF_VALIGN       0x0001   /* valign was explicitly set */
#define TABRF_FIRSTROW     0x0002   /* First row of a group */
#define TABRF_INHERITING   0x0004   /* This row inherits rowspan cells from prior rows */
#define TABRF_BORTOP       0x0008   /* this row has a rule on top */
#define TABRF_BORBOTTOM    0x0010   /* this row has a rule below */

#define TABRS_INITIAL      0  /* Still defining */
#define TABRS_COMPLETE     1  /* Fully defined, ready to be measured and further */
#define TABRS_MEASURED     2
#define TABRS_LAYEDOUT     3
#define TABRS_ALIGNED      4
#define TABRS_RENDERED     5

struct Tabcell
{  NODE(Tabcell);
   short cellnr;              /* This cell's id nr starting with 1 */
   short rowspan,colspan;     /* Span of this cell or zero if span extension */
   struct Aobject *body;      /* Cell contents or NULL if cell is span extension */
   long x,y;                  /* Cell position within table */
   long width,height;         /* Cell dimensions */
   long dy;                   /* Offset of body within cell */
   short halign,valign;       /* Alignment of cell */
   short swidth;              /* Suggested width */
   UWORD swtype;             /* Suggested width type */
   short sheight;             /* Suggested height */
   UWORD shtype;             /* Suggested height type (relative not supported) */
   UWORD flags;
   long maxw,minw;            /* Widths of contents after measure (including padding) */
   long baseline;             /* Baseline height for this cell */
   void *bgimage;             /* Background image */
   struct Aobject *bgalign;   /* object to align image to */
   struct Colorinfo *bgcolor,*bordercolor,*borderdark,*borderlight;
                              /* Common colours */
};

#define TABCF_NOWRAP       0x0001   /* No word wrapping in this cell */
#define TABCF_BORLEFT      0x0010   /* Draw left border */
#define TABCF_BORTOP       0x0020   /* Draw top border */
#define TABCF_BORRIGHT     0x0040   /* Draw right border */
#define TABCF_BORBOTTOM    0x0080   /* Draw bottom border */
#define TABCF_COLSPAN0     0x0100   /* Colspan until end of table */
#define TABCF_ROWSPAN0     0x0200   /* Rowspan until end of table */

struct Tabcol
{  long minw,maxw;            /* Minimum and maximum column widths */
   long width;                /* Resulting width in pixels (spacing excluded) */
   long x;                    /* X offset relative to table (spacing included) */
   long swidth;               /* Suggested width */
   UWORD swtype;             /* Suggested width type */
   UWORD flags;              /* flags for borders etc use TABCF_ */
};

#define SWT_UNSIZED     0
#define SWT_PIXELS      1
#define SWT_PERCENT     2
#define SWT_RELATIVE    3

#define COLOR(ci) ((ci)?((ci)->pen):(-1))

/*------------------------------------------------------------------------*/

/*------------------------------------------------------------------------*/

/* Add column definitions */
static void Addcoldefs(struct Table *tab,struct TagItem *tstate,UWORD flags)
{  struct TagItem *tag;
   struct Coldef *cd;
   short span=1;
   short swidth=1;
   UWORD swtype=SWT_RELATIVE;
   short halign=HALIGN_LEFT,valign=VALIGN_MIDDLE;
   short i;
   if(tstate)
   {  while(tag=NextTagItem(&tstate))
      {  switch(tag->ti_Tag)
         {  case AOTAB_Colspan:
               span=MAX(1,(short)tag->ti_Data);
               break;
            case AOTAB_Relwidth:
               if((short)tag->ti_Data>0)
               {  swidth=tag->ti_Data;
                  swtype=SWT_RELATIVE;
               }
               else
               {  swidth=1;
                  swtype=SWT_PIXELS;
               }
               break;
            case AOTAB_Percentwidth:
               if((short)tag->ti_Data>0)
               {  swidth=tag->ti_Data;
                  swtype=SWT_PERCENT;
               }
               else
               {  swidth=1;
                  swtype=SWT_PIXELS;
               }
               break;
            case AOTAB_Pixelwidth:
               swidth=MAX(1,(short)tag->ti_Data);
               swtype=SWT_PIXELS;
               break;
            case AOTAB_Halign:
               halign=tag->ti_Data;
               flags|=CDF_HALIGN;
               break;
            case AOTAB_Valign:
               valign=tag->ti_Data;
               break;
         }
      }
   }
   for(i=0;i<span;i++)
   {  if(cd=PALLOCSTRUCT(Coldef,1,0,tab->pool))
      {  cd->groupnr=tab->colgroupnr;
         cd->swidth=swidth;
         cd->swtype=swtype;
         cd->halign=halign;
         cd->valign=valign;
         cd->flags=flags;
         ADDTAIL(&tab->coldefs,cd);
         tab->nrcols++;
         tab->realcols=tab->nrcols;
         /* Always set "last column of group" flag, reset when another
          * column is added in the same group. */
         cd->flags|=CDF_LASTCOL;
         if(cd->prev->prev && cd->prev->groupnr==cd->groupnr)
         {  cd->prev->flags&=~CDF_LASTCOL;
         }
         else
         {  cd->flags|=CDF_FIRSTCOL;
         }
      }
   }
}

/* Start a new COLGROUP. Generate as many columns as necessary. */
static BOOL Startcolgroup(struct Table *tab,struct TagItem *tstate)
{  if(ISEMPTY(&tab->rows))
   {  tab->colgroupnr++;
      Addcoldefs(tab,tstate,CDF_GENERATED);
   }
   return TRUE;
}

/* End a COLGROUP. Just increase the id number so the last column isn't
 * identified as member of the current or next group. */
static void Endcolgroup(struct Table *tab)
{  if(ISEMPTY(&tab->rows))
   {  tab->colgroupnr++;
   }
}

/* Generate column definitions from COL tag. */
static BOOL Startcolumn(struct Table *tab,struct TagItem *tstate)
{  struct Coldef *cd;
   if(ISEMPTY(&tab->rows))
   {  /* If the last Coldef is of the current group and was generated,
       * delete all generated Coldefs of this group. They are replaced
       * by <COL> definitions. */
      for(cd=tab->coldefs.last;
          cd->prev && cd->groupnr==tab->colgroupnr && (cd->flags&CDF_GENERATED);
          cd=tab->coldefs.last)
      {  REMOVE(cd);
         FREE(cd);
         tab->nrcols--;
      }
      Addcoldefs(tab,tstate,0);
   }
   return TRUE;
}

/* End a row group. Just increase the id number and reset the TFOOT flag. */
static void Endrowgroup(struct Table *tab)
{  tab->rowgroupnr++;
   if(tab->flags&TABF_TFOOT)
   {  short r;
      tab->flags&=~TABF_TFOOT;
      r=tab->currow;
      tab->currow=tab->footrow;
      tab->footrow=r;
   }
}

/* Start a new row group */
static BOOL Startrowgroup(struct Table *tab,struct TagItem *tstate)
{  struct TagItem *tag;
   Endrowgroup(tab);
   tab->rghalign=HALIGN_LEFT;
   tab->rgvalign=VALIGN_MIDDLE;
   tab->flags&=~TABF_RGVALIGN;
   if(tstate)
   {  while(tag=NextTagItem(&tstate))
      {  switch(tag->ti_Tag)
         {  case AOTAB_Halign:
               tab->rghalign=tag->ti_Data;
               break;
            case AOTAB_Valign:
               tab->rgvalign=tag->ti_Data;
               tab->flags|=TABF_RGVALIGN;
               break;
         }
      }
   }
   return TRUE;
}

/* Start the TFOOT group */
static BOOL Starttfoot(struct Table *tab,struct TagItem *tstate)
{  if(!(tab->flags&TABF_TFOOT))
   {  short r;
      Startrowgroup(tab,tstate);
      tab->flags|=TABF_TFOOT;
      r=tab->footrow;
      tab->footrow=tab->currow;
      tab->currow=r;
   }
   return TRUE;
}

/* Return the row for this number. If none exists, create a new one. */
static struct Tabrow *Gettabrow(struct Table *tab,long nr)
{  struct Tabrow *tr;
   LIST(Tabrow) *list;
   if(tab->flags&TABF_TFOOT) list=(APTR)&tab->tfoot;
   else list=(APTR)&tab->rows;
   /* if number is in second half, start from list tail */
   if(list->last->prev && nr>list->last->rownr/2)
   {  for(tr=list->last;tr->prev;tr=tr->prev)
      {  if(tr->rownr==nr) return tr;
         if(tr->rownr<nr) break;
      }
   }
   else
   {  for(tr=list->first;tr->next;tr=tr->next)
      {  if(tr->rownr==nr) return tr;
      }
   }
   if(tr=PALLOCSTRUCT(Tabrow,1,MEMF_CLEAR,tab->pool))
   {  NEWLIST(&tr->cells);
      ADDTAIL(list,tr);
      tr->rownr=nr;
   }
   return tr;
}

/* Add a cell to this row. If cellnr==0, use first free number */
static struct Tabcell *Addtabcell(struct Table *tab,long rownr,long cellnr)
{  struct Tabrow *tr=Gettabrow(tab,rownr);
   struct Tabcell *tc,*c;
   struct Coldef *cd;
   short i;
   if(!tr) return NULL;
   if(tc=PALLOCSTRUCT(Tabcell,1,MEMF_CLEAR,tab->pool))
   {  if(!cellnr)
      {  for(cellnr=1,c=tr->cells.first;c->next;c=c->next)
         {  if(c->cellnr>cellnr) break;
            cellnr=c->cellnr+1;
         }
      }
      tc->cellnr=cellnr;
      for(c=tr->cells.first;c->next && c->cellnr<tc->cellnr;c=c->next);
      INSERT(&tr->cells,tc,c->prev);
      if(tr->nrcells<tc->cellnr)
      {  tr->nrcells=tc->cellnr;
         if(tab->nrcols<tr->nrcells) tab->nrcols=tr->nrcells;
      }
      tc->halign=tr->halign;
      tc->valign=tr->valign;
      for(i=1,cd=tab->coldefs.first;i<cellnr && cd->next;i++,cd=cd->next);
      if(cd->next)
      {  /* Halign in COL overrides TR, Valign in TR overrides COL. */
         if(cd->flags&CDF_HALIGN) tc->halign=cd->halign;
         if(!(tr->flags&TABRF_VALIGN)) tc->valign=cd->valign;
      }
   }
   return tc;
}

/* End this body by adding it a line break. Body can be a cell or a caption. */
static void Endbody(struct Table *tab,void *body,long vspacing)
{  void *elt;
   if(vspacing<1)
   {  if(elt=Anewobject(AOTP_BREAK,
         AOBJ_Pool,(Tag)tab->pool,
         TAG_END))
      {  Aaddchild(tab->curbody,elt,0);
      }
   }
   Asetattrs(body,AOBDY_End,TRUE,TAG_END);
}

/* Close the caption. */
static void Endcaption(struct Table *tab,long vspacing)
{  if((tab->flags&TABF_OPENCAPTION) && tab->curbody)
   {  if(tab->curbody) Endbody(tab,tab->curbody,vspacing);
      tab->curbody=NULL;
      tab->flags&=~TABF_OPENCAPTION;
   }
}

/* Close current cell. */
static void Endcell(struct Table *tab,long vspacing)
{  if((tab->flags&TABF_OPENCELL) && tab->curbody)
   {  if(tab->curbody) Endbody(tab,tab->curbody,vspacing);
      tab->curbody=NULL;
      tab->flags&=~TABF_OPENCELL;
   }
}

/* Close current row. */
static void Endrow(struct Table *tab,long vspacing)
{  if(tab->flags&TABF_OPENROW)
   {  if(tab->flags&TABF_OPENCELL) Endcell(tab,vspacing);
      tab->flags&=~TABF_OPENROW;
   }
}

/* Start the caption. If (testate)==NULL, use defaults. */
static BOOL Startcaption(struct Table *tab,struct TagItem *tstate,long vspacing)
{  struct TagItem *tag;
   short halign=HALIGN_CENTER;
   if(!tab->caption)
   {  if(tab->flags&TABF_OPENROW)
      {  Endrow(tab,vspacing);
         /* Caption not specified as first element, so it's a bottom caption. */
         tab->flags|=TABF_CAPBOTTOM;
      }
      if(tstate)
      {  while(tag=NextTagItem(&tstate))
         {  switch(tag->ti_Tag)
            {  case AOTAB_Valign:
                  if(tag->ti_Data==VALIGN_BOTTOM) tab->flags|=TABF_CAPBOTTOM;
                  break;
               case AOTAB_Halign:
                  halign=tag->ti_Data;
                  break;
            }
         }
      }
      tab->caption=Anewobject(AOTP_BODY,
         AOBJ_Pool,(Tag)tab->pool,
         AOBJ_Frame,(Tag)tab->frame,
         AOBJ_Cframe,(Tag)tab->elt.cframe,
         AOBJ_Window,(Tag)tab->win,
         AOBJ_Nobackground,BOOLVAL(tab->flags&TABF_NOBACKGROUND),
         AOBJ_Layoutparent,(Tag)tab,
         AOBDY_Leftmargin,tab->padding,
         AOBDY_Topmargin,tab->padding,
         AOBDY_Divalign,halign,
         TAG_END);
      if(tab->win)
      {  Asetattrs(tab->caption,
            AOBDY_Bgimage,0,     /* was tab->bgimage */
            AOBDY_Bgalign,0,     /* was tab->bgalign */
            AOBDY_Bgcolor,0,     /* was COLOR(tab->bgcolor) */
            TAG_END);
      }

      tab->curbody=tab->caption;
      tab->flags|=TABF_OPENCAPTION;
   }
   return TRUE;
}

/* Start a new row. If (tstate)==NULL, use defaults. */
static BOOL Startrow(struct Table *tab,struct TagItem *tstate,long vspacing)
{  struct TagItem *tag;
   struct Tabrow *tr,*tra;
   struct Tabcell *tc,*tca;
   BOOL bgcolset=FALSE, bgimgset=FALSE ,borderset=FALSE;

   if(tab->flags&TABF_OPENCAPTION) Endcaption(tab,vspacing);
   if(tab->flags&TABF_OPENROW) Endrow(tab,vspacing);
   if(tr=Gettabrow(tab,++tab->currow))
   {  tab->flags|=TABF_OPENROW;
      tr->groupnr=tab->rowgroupnr;
      tr->halign=tab->rghalign;
      tr->valign=tab->rgvalign;
      if(tab->flags&TABF_RGVALIGN) tr->flags|=TABRF_VALIGN;
      tr->borderdark=tab->borderdark;
      tr->borderlight=tab->borderlight;
      if(tr->prev->prev && tr->prev->groupnr==tr->groupnr)
      {  /* Remove bottom borders from previous row if rules=groups */
         if(tab->rules==TABRUL_GROUPS)
         {  for(tc=tr->prev->cells.first;tc->next;tc=tc->next)
            {  tc->flags&=~TABCF_BORBOTTOM;
            }
         }
      }
      else
      {  tr->flags|=TABRF_FIRSTROW;
      }
      if(tstate)
      {  while(tag=NextTagItem(&tstate))
         {  switch(tag->ti_Tag)
            {  case AOTAB_Halign:
                  tr->halign=tag->ti_Data;
                  break;
               case AOTAB_Valign:
                  tr->valign=tag->ti_Data;
                  tr->flags|=TABRF_VALIGN;
                  break;
               case AOTAB_Bgimage:
                  if(tag->ti_Data)
                  {  tr->bgimage=(void *)tag->ti_Data;
                     bgimgset=TRUE;
                  }
                  break;
               case AOTAB_Bgcolor:
                  if(tag->ti_Data)
                  {  tr->bgcolor=(struct Colorinfo *)tag->ti_Data;
                     bgcolset=TRUE;
                  }
                  break;
               case AOTAB_Bordercolor:
                  if(tag->ti_Data)
                  {  tr->bordercolor=(struct Colorinfo *)tag->ti_Data;
                     borderset=TRUE;
                  }
                  break;
               case AOTAB_Borderdark:
                  if(tag->ti_Data)
                  {  tr->borderdark=(struct Colorinfo *)tag->ti_Data;
                     borderset=TRUE;
                  }
                  break;
               case AOTAB_Borderlight:
                  if(tag->ti_Data)
                  {  tr->borderlight=(struct Colorinfo *)tag->ti_Data;
                     borderset=TRUE;
                  }
                  break;
            }
         }
      }

      if(!bgimgset && !bgcolset)
      {  tr->bgimage=tab->bgimage;
         tr->bgalign=tab->bgalign;
      }
      if(!bgcolset)
      {
         tr->bgcolor=tab->bgcolor;
      }

      if(!borderset)
      {  tr->bordercolor=tab->bordercolor;
      }
      if(!ISEMPTY(&tr->cells))
      {  tr->flags|=TABRF_INHERITING;
      }
      /* If the previous row has cells with ROWSPAN=0, duplicate these now */
      if(tr->prev->prev)
      {  for(tc=tr->prev->cells.first;tc->next;tc=tc->next)
         {  if(tc->flags&TABCF_ROWSPAN0)
            {  if(tca=Addtabcell(tab,tr->rownr,tc->cellnr))
               {  tca->flags=tc->flags&~TABCF_BORTOP;
                  tca->flags|=(tc->flags&TABCF_BORBOTTOM);
                  tc->flags&=~TABCF_BORBOTTOM;
               }
            }
         }
      }
      /* If there are prior rows, and this row has no span extension cells,
       * and the table allows incremental display, allow that now. */
      if((tab->elt.eltflags&ELTF_ALIGNED)
      && prefs.browser.inctable
      && !(tab->flags&TABF_TFOOT) && (tab->flags&TABF_INCREMENTAL)
      && !(tr->flags&TABRF_INHERITING) && tr->prev->prev)
      {  for(tra=tr->prev;tra->prev;tra=tra->prev)
         {  if(tra->state) break;
            tra->state=TABRS_COMPLETE;
            Asetattrs(tab->parent,AOBJ_Changedchild,(Tag)tab,TAG_END);
         }
      }
   }
   return TRUE;
}

/* Start a new cell in the current row. If (tstate)==NULL, use defaults from row. */
static BOOL Startcell(struct Table *tab,struct TagItem *tstate,long vspacing,BOOL heading)
{  struct TagItem *tag;
   struct Tabrow *tr;
   struct Tabcell *tc,*tcs;
   struct Coldef *cd0,*cd;
   short r,c;
   BOOL bgcolset=FALSE, bgimgset=FALSE, borderset=FALSE;

   if(tab->flags&TABF_OPENCELL) Endcell(tab,vspacing);
   if(!(tab->flags&TABF_OPENROW)) Startrow(tab,NULL,vspacing);
   if(tr=Gettabrow(tab,tab->currow))
   {  if(tc=Addtabcell(tab,tr->rownr,0))
      {  tc->rowspan=1;
         tc->colspan=1;
         if(heading)
         {  tc->halign=HALIGN_CENTER;
            tc->valign=VALIGN_MIDDLE;
         }
         tab->flags|=TABF_OPENCELL;
         tc->borderdark=tr->borderdark;
         tc->borderlight=tr->borderlight;
         if(tstate)
         {  while(tag=NextTagItem(&tstate))
            {  switch(tag->ti_Tag)
               {  case AOTAB_Halign:
                     tc->halign=tag->ti_Data;
                     break;
                  case AOTAB_Valign:
                     tc->valign=tag->ti_Data;
                     break;
                  case AOTAB_Rowspan:
                     tc->rowspan=(short)tag->ti_Data;
                     if(tc->rowspan==0)
                     {  tc->rowspan=1;
                        tc->flags|=TABCF_ROWSPAN0;
                     }
                     break;
                  case AOTAB_Colspan:
                     tc->colspan=(short)tag->ti_Data;
                     if(tc->colspan==0)
                     {  tc->colspan=1;
                        tc->flags|=TABCF_COLSPAN0;
                     }
                     break;
                  case AOTAB_Nowrap:
                     if(tag->ti_Data) tc->flags|=TABCF_NOWRAP;
                     break;
                  case AOTAB_Relwidth:
                     if((short)tag->ti_Data>0)
                     {  tc->swidth=tag->ti_Data;
                        tc->swtype=SWT_RELATIVE;
                     }
                     else
                     {  tc->swidth=1;
                        tc->swtype=SWT_PIXELS;
                     }
                     break;
                  case AOTAB_Percentwidth:
                     if((short)tag->ti_Data>0)
                     {  tc->swidth=tag->ti_Data;
                        tc->swtype=SWT_PERCENT;
                     }
                     else
                     {  tc->swidth=1;
                        tc->swtype=SWT_PIXELS;
                     }
                     break;
                  case AOTAB_Pixelwidth:
                     tc->swidth=MAX(1,(short)tag->ti_Data);
                     tc->swtype=SWT_PIXELS;
                     break;
                  case AOTAB_Percentheight:
                     tc->sheight=(short)tag->ti_Data;
                     tc->shtype=SWT_PERCENT;
                     break;
                  case AOTAB_Pixelheight:
                     tc->sheight=(short)tag->ti_Data;
                     tc->shtype=SWT_PIXELS;
                     break;
                  case AOTAB_Bgimage:
                     if(tag->ti_Data)
                     {  tc->bgimage=(void *)tag->ti_Data;
                        bgimgset=TRUE;
                     }
                     break;
                  case AOTAB_Bgcolor:
                     if(tag->ti_Data)
                     {  tc->bgcolor=(struct Colorinfo *)tag->ti_Data;
                        bgcolset=TRUE;
                     }
                     break;
                  case AOTAB_Bordercolor:
                     if(tag->ti_Data)
                     {  tc->bordercolor=(struct Colorinfo *)tag->ti_Data;
                        borderset=TRUE;
                     }
                     break;
                  case AOTAB_Borderdark:
                     if(tag->ti_Data)
                     {  tc->borderdark=(struct Colorinfo *)tag->ti_Data;
                        borderset=TRUE;
                     }
                     break;
                  case AOTAB_Borderlight:
                     if(tag->ti_Data)
                     {  tc->borderlight=(struct Colorinfo *)tag->ti_Data;
                        borderset=TRUE;
                     }
                     break;
               }
            }
         }
         if(!bgimgset && !bgcolset)
         {
            tc->bgimage=tr->bgimage;
         }
         if(!bgcolset)
         {
            tc->bgcolor=tr->bgcolor;
         }

         if(!borderset)
         {  tc->bordercolor=tr->bordercolor;
         }

    /* Removed next line so that NOWRAP overides table width when set */
    /*     if(tc->swidth) tc->flags&=~TABCF_NOWRAP; */

         /* Allocate empty cells for spanned cells and set border flags. */
         for(c=1,cd0=tab->coldefs.first;c<tc->cellnr && cd0->next;c++,cd0=cd0->next);
         for(r=0;r<tc->rowspan;r++)
         {  if(cd0->next) cd=cd0;
            else cd=NULL;
            for(c=0;c<tc->colspan;c++)
            {  if(r>0 || c>0) /* We've got (r==0,c==0) already */
               {  tcs=Addtabcell(tab,tab->currow+r,tc->cellnr+c);
               }
               else tcs=tc;
               if(tcs)
               {  tcs->bordercolor=tc->bordercolor;
                  tcs->borderdark=tc->borderdark;
                  tcs->borderlight=tc->borderlight;
                  if(tab->rules==TABRUL_ALL || tab->rules==TABRUL_ROWS)
                  {  if(r==0) tcs->flags|=TABCF_BORTOP;
                     if(r==tc->rowspan-1) tcs->flags|=TABCF_BORBOTTOM;
                  }
                  if(tab->rules==TABRUL_ALL || tab->rules==TABRUL_COLS)
                  {  if(c==0) tcs->flags|=TABCF_BORLEFT;
                     if(c==tc->colspan-1) tcs->flags|=TABCF_BORRIGHT;
                  }
                  if(tab->rules==TABRUL_GROUPS)
                  {  if(r==0 && (tr->flags&TABRF_FIRSTROW))
                     {
                      tcs->flags|=TABCF_BORTOP;
                     }
                     /* Set bottom border, will be removed when another row
                      * is added in the same group */
                     if(r==tc->rowspan-1) tcs->flags|=TABCF_BORBOTTOM;
                     if(c==0 && cd && (cd->flags&CDF_FIRSTCOL))
                     {
                      tcs->flags|=TABCF_BORLEFT;
                     }
                     if(c==tc->colspan-1 && cd && (cd->flags&CDF_LASTCOL))
                     {
                        tcs->flags|=TABCF_BORRIGHT;
                     }
                  }
               }
               if(cd && cd->next->next) cd=cd->next;
               else cd=NULL;
            }
         }
         tc->body=Anewobject(AOTP_BODY,
            AOBJ_Pool,(Tag)tab->pool,
            AOBJ_Frame,(Tag)tab->frame,
            AOBJ_Cframe,(Tag)tab->elt.cframe,
            AOBJ_Window,(Tag)tab->win,
            AOBJ_Nobackground,BOOLVAL(tab->flags&TABF_NOBACKGROUND),
            AOBJ_Layoutparent,(Tag)tab,
            AOBDY_Tcell,(Tag)tc,
            AOBDY_Leftmargin,tab->padding,
            AOBDY_Topmargin,tab->padding,
            AOBDY_Divalign,tc->halign,
            (heading?AOBDY_Sethardstyle:TAG_IGNORE),FSF_BOLD,
            TAG_END);

         /* if tr->bgalign is not set yet set to our object */
         if(tr->bgalign == NULL)
         {
            tr->bgalign = tc->body;
         }
         if(tab->win)
         {  Asetattrs(tc->body,
               AOBDY_Bgimage,(Tag)tc->bgimage,
               AOBDY_Bgalign,(Tag)(bgimgset?tc->body:tr->bgalign),
               AOBDY_Bgcolor,COLOR(tc->bgcolor),
               TAG_END);
         }
         tab->curbody=tc->body;
         if(tc->cellnr>tab->realcols) tab->realcols=tc->cellnr;
      }
   }
   return TRUE;
}

/* Cut off bottom rows in this row list that only contain span extension
 * (not real) cells.
 * Cut off span extension columns beyond (realcols).
 * Add span cells for COLSPAN=0 cells.
 * Adjust colspan and rowspan numbers. */
static void Cutoffrows(struct Table *tab,void *alist)
{  struct Tabrow *tr;
   struct Tabcell *tc,*tcnext,*tca,*tc0;
   LIST(Tabrow) *list=alist;
   BOOL real;
   long lastrownr;
   tr=list->last;
   real=FALSE;
   while(!real && tr->prev)
   {  for(tc=tr->cells.first;!real && tc->next;tc=tc->next)
      {  if(tc->rowspan) real=TRUE;
      }
      if(!real)
      {  REMOVE(tr);
         while(tc=(struct Tabcell *)REMHEAD(&tr->cells))
         {  if(tc->body) Adisposeobject(tc->body);
            FREE(tc);
         }
         FREE(tr);
         tr=list->last;
      }
   }
   lastrownr=list->last->rownr;
   for(tr=list->first;tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next;tc=tcnext)
      {  tcnext=tc->next;
         if(tc->cellnr>tab->realcols)
         {  REMOVE(tc);
            if(tc->body) Adisposeobject(tc->body);
            FREE(tc);
         }
         else
         {  if(tc->cellnr+tc->colspan>tab->realcols+1)
            {  tc->colspan=tab->realcols-tc->cellnr+1;
            }
            if(tr->rownr+tc->rowspan>lastrownr+1)
            {  tc->rowspan=lastrownr-tr->rownr+1;
            }
            else if((tc->flags&TABCF_ROWSPAN0) && tc->rowspan>0)
            {  tc->rowspan=lastrownr-tr->rownr+1;
            }
            if(tc->cellnr==tab->realcols && tab->rules && tab->rules!=TABRUL_ROWS)
            {  tc->flags|=TABCF_BORRIGHT;
            }
            if(tc->cellnr==1 && tab->rules && tab->rules!=TABRUL_ROWS)
            {  tc->flags|=TABCF_BORLEFT;
            }

            if(tr->rownr==lastrownr && tab->rules && tab->rules!=TABRUL_COLS)
            {  tc->flags|=TABCF_BORBOTTOM;
            }
         }
      }
      tc=tr->cells.last;
      if(tc->prev && (tc->flags&TABCF_COLSPAN0))
      {  tc0=tc;
         while(tc->cellnr<tab->realcols)
         {  if(tca=Addtabcell(tab,tr->rownr,tc->cellnr+1))
            {  tca->flags=tc->flags&~TABCF_BORLEFT;
               tca->flags|=(tc->flags&TABCF_BORRIGHT);
               tc->flags&=~TABCF_BORRIGHT;
               tc=tca;
               tc0->colspan++;
            }
         }
      }
   }
}

/* Close table */
static void Endtable(struct Table *tab,long vspacing)
{  struct Tabrow *tr;
   if(!tab->nrcols)
   {  Startcell(tab,NULL,vspacing,FALSE);
   }
   if(tab->flags&TABF_OPENCAPTION) Endcaption(tab,vspacing);
   if(tab->flags&TABF_OPENROW) Endrow(tab,vspacing);
   Cutoffrows(tab,&tab->rows);
   Cutoffrows(tab,&tab->tfoot);
   /* Move tfoot rows to bottom of table */
   while(tr=(struct Tabrow *)REMHEAD(&tab->tfoot))
   {  tr->rownr=++tab->currow;
      ADDTAIL(&tab->rows,tr);
   }
   /* Set all rows to complete */
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  if(!tr->state) tr->state=TABRS_COMPLETE;
   }
   tab->nrcols=tab->realcols;
   tab->flags|=TABF_COMPLETE;
}

/* Reset the row state to complete for all rows with higher state below this absolute y */
static void Resetrowstate(struct Table *tab,long y)
{  struct Tabrow *tr;
   y=y-tab->elt.aoy-tab->spacing/2;   /* Make it a relative row y */
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  if(tr->y+tr->height>y)
      {  /* Point of relayout falls within this row. Find last non-inheriting
          * row above this one */
         for(;tr->prev && (tr->flags&TABRF_INHERITING);tr=tr->prev);
         if(!tr->prev) tr=tab->rows.first;   /* Shouldn't be needed, but Murphy rules... */
         if(tab->elt.aoh>tr->y) tab->elt.aoh=tr->y;
         break;
      }
   }
   for(;tr->next;tr=tr->next)
   {  if(tr->state>TABRS_COMPLETE) tr->state=TABRS_COMPLETE;
   }
   /* Test if within top caption */
   if(tab->rows.first->next && y<tab->rows.first->y && !(tab->flags&TABF_CAPBOTTOM))
   {  if(tab->capstate>TABRS_COMPLETE) tab->capstate=TABRS_COMPLETE;
      tab->elt.aoh=tab->bortop;
   }
   /* Test if within bottom caption */
   if(tab->rows.last->prev && y>=tab->rows.last->y+tab->rows.last->height
   && (tab->flags&TABF_CAPBOTTOM))
   {  if(tab->capstate>TABRS_COMPLETE) tab->capstate=TABRS_COMPLETE;
      tab->elt.aoh=tab->rows.last->y+tab->rows.last->height+tab->spacing;
   }
   if(tab->incrementaly>tab->elt.aoh) tab->incrementaly=tab->elt.aoh;
}

/* Returns current body. If no current body, create row and cell as necessary */
static void *Currentbody(struct Table *tab,long vspacing)
{  if(!(tab->flags&TABF_OPENCAPTION))
   {  if(!(tab->flags&TABF_OPENROW)) Startrow(tab,NULL,vspacing);
      if(!(tab->flags&TABF_OPENCELL)) Startcell(tab,NULL,vspacing,FALSE);
   }
   return tab->curbody;
}

/* Send this message to all table cell bodies */
static void Broadcast(struct Table *tab,struct Amessage *amsg)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   if(tab->caption && !(tab->flags&TABF_CAPBOTTOM))
   {  AmethodA(tab->caption,amsg);
   }
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next;tc=tc->next)
      {  if(tc->body)
         {  AmethodA(tc->body,amsg);
         }
      }
   }
   if(tab->caption && (tab->flags&TABF_CAPBOTTOM))
   {  AmethodA(tab->caption,amsg);
   }
}

/* Send this message to all table cell bodies until one returns nonzero*/
static long Broadcastnz(struct Table *tab,struct Amessage *amsg)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   long result=0;
   if(tab->caption && !(tab->flags&TABF_CAPBOTTOM))
   {  result=AmethodA(tab->caption,amsg);
   }
   for(tr=tab->rows.first;tr->next && !result;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next && !result;tc=tc->next)
      {  if(tc->body)
         {  result=AmethodA(tc->body,amsg);
         }
      }
   }
   if(!result && tab->caption && (tab->flags&TABF_CAPBOTTOM))
   {  result=AmethodA(tab->caption,amsg);
   }
   return result;
}

/* Set all cells body's background colour */
static void Setcolors(struct Table *tab)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   if(tab->caption)
   {  Asetattrs(tab->caption,AOBDY_Bgcolor,COLOR(tab->bgcolor),TAG_END);
   }
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next;tc=tc->next)
      {  if(tc->body)
         {  Asetattrs(tc->body,AOBDY_Bgcolor,COLOR(tc->bgcolor),TAG_END);
         }
      }
   }
}

/* Render inner cell borders, clipped */
static void Rendercellborder(struct Table *tab,struct Coords *coo,
   struct Tabrow *tr,struct Tabcell *tc)
{  long x1,y1,x2,y2;
   short pen;
   struct Colorinfo *ci1,*ci2;
   struct Tabcol *hcol;
   ci1=tc->bordercolor?tc->bordercolor:tc->borderdark;
   ci2=tc->bordercolor?tc->bordercolor:tc->borderlight;
   hcol=&tab->cols[tc->cellnr-1];
   if(tc->flags&TABCF_BORLEFT)
   {  if(prefs.browser.docolors && ci1 && ci1->pen>=0) pen=ci1->pen;
      else pen=coo->dri->dri_Pens[SHADOWPEN];
      x1=tab->elt.aox+coo->dx + hcol->x - 1;
      y1=tab->elt.aoy+coo->dy + tr->y - 1 - tab->spacing;
      y2=y1+tr->height+2*tab->spacing+1;
      if(tc->flags&TABCF_BORTOP) y1+=tab->spacing;
      if(tc->flags&TABCF_BORBOTTOM) y2-=tab->spacing;
      if(x1>=coo->minx && x1<=coo->maxx && y2>=coo->miny && y1<=coo->maxy)
      {  SetAPen(coo->rp,pen);
         Move(coo->rp,x1,MAX(y1,coo->miny));
         Draw(coo->rp,x1,MIN(y2,coo->maxy));
      }
   }
   if(tc->flags&TABCF_BORTOP)
   {  if(prefs.browser.docolors && ci1 && ci1->pen>=0) pen=ci1->pen;
      else pen=coo->dri->dri_Pens[SHADOWPEN];
      x1=tab->elt.aox+coo->dx+hcol->x - 1 - tab->spacing;
      x2=x1+hcol->width+2*tab->spacing+1;
      y1=tab->elt.aoy+coo->dy+tr->y -1;
      if(tc->flags&TABCF_BORLEFT) x1+=tab->spacing;
      if(tc->flags&TABCF_BORRIGHT) x2-=tab->spacing;
      if(y1>=coo->miny && y1<=coo->maxy && x2>=coo->minx && x1<=coo->maxx)
      {  SetAPen(coo->rp,pen);
         Move(coo->rp,MAX(x1,coo->minx),y1);
         Draw(coo->rp,MIN(x2,coo->maxx),y1);
      }
   }
   if(tc->flags&TABCF_BORRIGHT)
   {  if(prefs.browser.docolors && ci2 && ci2->pen>=0) pen=ci2->pen;
      else pen=coo->dri->dri_Pens[SHINEPEN];
      x1=tab->elt.aox + coo->dx + hcol->x + hcol->width;
      y1=tab->elt.aoy + coo->dy + tr->y -1 - tab->spacing;
      y2=y1+tr->height+2*tab->spacing+1;
      if(tc->flags&TABCF_BORTOP) y1+=tab->spacing;
      if(tc->flags&TABCF_BORBOTTOM) y2-=tab->spacing;
      if(x1>=coo->minx && x1<=coo->maxx && y2>=coo->miny && y1<=coo->maxy)
      {  SetAPen(coo->rp,pen);
         Move(coo->rp,x1,MAX(y1,coo->miny));
         Draw(coo->rp,x1,MIN(y2,coo->maxy));
      }
   }
   if(tc->flags&TABCF_BORBOTTOM)
   {  if(prefs.browser.docolors && ci2 && ci2->pen>=0) pen=ci2->pen;
      else pen=coo->dri->dri_Pens[SHINEPEN];
      x1=tab->elt.aox+coo->dx+hcol->x-1 - tab->spacing;
      x2=x1+hcol->width+2*tab->spacing+1;
      y1=tab->elt.aoy+coo->dy+tr->y+tr->height;
      if(tc->flags&TABCF_BORLEFT) x1+=tab->spacing;
      if(tc->flags&TABCF_BORRIGHT) x2-=tab->spacing;
      if(y1>=coo->miny && y1<=coo->maxy && x2>=coo->minx && x1<=coo->maxx)
      {  SetAPen(coo->rp,pen);
         Move(coo->rp,MAX(x1,coo->minx),y1);
         Draw(coo->rp,MIN(x2,coo->maxx),y1);
      }
   }
}

/* Render outer table frame, clipped */
static void Rendertabframe(struct Table *tab,struct Coords *coo)
{  long x1,y1,x2,y2;
   short pen,i;
   struct Colorinfo *ci1,*ci2;
   ci1=tab->bordercolor?tab->bordercolor:tab->borderlight;
   ci2=tab->bordercolor?tab->bordercolor:tab->borderdark;

   if(tab->tabframe&TABFRM_LEFT)
   {  if(prefs.browser.docolors && ci1 && ci1->pen>=0) pen=ci1->pen;
      else pen=coo->dri->dri_Pens[SHINEPEN];
      x1=tab->elt.aox+coo->dx;
      y1=tab->elt.aoy+coo->dy;
      x2=x1+tab->borleft-1;
      y2=y1+tab->elt.aoh-1;
      if(x2>=coo->minx && x1<=coo->maxx)
      {  SetAPen(coo->rp,pen);
         RectFill(coo->rp,MAX(x1,coo->minx),MAX(y1,coo->miny),
            MIN(x2,coo->maxx),MIN(y2,coo->maxy));
      }
   }
   if(tab->tabframe&TABFRM_ABOVE)
   {  if(prefs.browser.docolors && ci1 && ci1->pen>=0) pen=ci1->pen;
      else pen=coo->dri->dri_Pens[SHINEPEN];
      x1=tab->elt.aox+coo->dx;
      y1=tab->elt.aoy+coo->dy;
      x2=x1+tab->elt.aow-1;
      y2=y1+tab->bortop-1;
      if(y2>=coo->miny && y1<=coo->maxy)
      {  SetAPen(coo->rp,pen);
         RectFill(coo->rp,MAX(x1,coo->minx),MAX(y1,coo->miny),
            MIN(x2,coo->maxx),MIN(y2,coo->maxy));
      }
   }
   if(tab->tabframe&TABFRM_RIGHT)
   {  if(prefs.browser.docolors && ci2 && ci2->pen>=0) pen=ci2->pen;
      else pen=coo->dri->dri_Pens[SHADOWPEN];
      x1=tab->elt.aox+coo->dx+tab->elt.aow-tab->borright;
      y1=tab->elt.aoy+coo->dy+tab->bortop;
      x2=x1+tab->borright-1;
      y2=tab->elt.aoy+coo->dy+tab->elt.aoh-1;
      if(x2>=coo->minx && x1<=coo->maxx && y1<=coo->maxy)
      {  SetAPen(coo->rp,pen);
         RectFill(coo->rp,MAX(x1,coo->minx),MAX(y1,coo->miny),
            MIN(x2,coo->maxx),MIN(y2,coo->maxy));
         for(i=1;i<tab->bortop;i++)
         {  Move(coo->rp,x1+i,y1-i);
            Draw(coo->rp,x1+i,y1-1);
         }
      }
   }
   if((tab->tabframe&TABFRM_BELOW) && (tab->flags&TABF_COMPLETE))
   {  if(prefs.browser.docolors && ci2 && ci2->pen>=0) pen=ci2->pen;
      else pen=coo->dri->dri_Pens[SHADOWPEN];
      x1=tab->elt.aox+coo->dx+tab->borleft-1;
      y1=tab->elt.aoy+coo->dy+tab->elt.aoh-tab->borbottom;
      x2=tab->elt.aox+coo->dx+tab->elt.aow-1;
      y2=y1+tab->borbottom-1;
      if(y2>=coo->miny && y1<=coo->maxy)
      {  SetAPen(coo->rp,pen);
         RectFill(coo->rp,MAX(x1,coo->minx),MAX(y1,coo->miny),
            MIN(x2,coo->maxx),MIN(y2,coo->maxy));
         for(i=1;i<tab->borleft;i++)
         {  Move(coo->rp,x1-i,y1+i);
            Draw(coo->rp,x1-1,y1+i);
         }
      }
   }
}

/*------------------------------------------------------------------------*/

static long Measuretable(struct Table *tab,struct Ammeasure *amm)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   struct Tabcol *hcol;
   struct Coldef *cd;
   long i,n,totalprc,totalrel,minuns,maxuns,minrel,ruprc,maxruw,w;
   long old,dw,minw,maxw,tcdw,tcminw,tcmaxw;
   UWORD mlf;
   struct Ammresult ammr={0};
   BOOL all;

   /* If incomplete and no incremental display, do nothing. */
   if(!prefs.browser.inctable) tab->flags&=~TABF_INCREMENTAL;
   if(!(tab->flags&(TABF_INCREMENTAL|TABF_COMPLETE))) return 0;

   /* Measure all if requested,
    * or if no incremental display is allowed and table is complete. */
   all=!(amm->flags&AMMF_CHANGED) || !(tab->flags&TABF_INCREMENTAL);

   /* Do nothing if not at least one row to measure */
   if(!(tab->rows.first->next && tab->rows.first->state)) return 0;

   /* Allocate column table if size changed. Stop incremental display
    * if number of columns changed underway. */
   if(tab->colssize>0 && tab->colssize!=tab->nrcols
   && !(tab->flags&TABF_COMPLETE))
   {  tab->flags&=~TABF_INCREMENTAL;
      return 0;
   }
   if(tab->colssize!=tab->nrcols)
   {  if(tab->cols) FREE(tab->cols);
      tab->cols=PALLOCSTRUCT(Tabcol,tab->nrcols,MEMF_CLEAR,tab->pool);
      if(!tab->cols) return 0;
      tab->colssize=tab->nrcols;
      all=TRUE;
      tab->flags&=~(TABF_LAYEDOUT|TABF_BBLAYEDOUT);
   }

   /* Reset all column attributes.
    * Initialize from Coldefs or set to default value. */
   cd=tab->coldefs.first;
   for(i=0;i<tab->nrcols;i++)
   {  hcol=&tab->cols[i];
      hcol->minw=hcol->maxw=0;
      if(cd->next)
      {  hcol->swidth=cd->swidth;
         hcol->swtype=cd->swtype;
         hcol->flags = 0;
         cd=cd->next;
      }
      else
      {  hcol->swidth=0;
         hcol->swtype=SWT_UNSIZED;
         hcol->flags = 0;
      }
   }

   /* Measure the caption */
   if(tab->caption
   && (tab->capstate<=TABRS_COMPLETE || (all && tab->capstate>TABRS_COMPLETE)))
   {  memset(&ammr,0,sizeof(ammr));
      Ameasure(tab->caption,amm->width,amm->height,0,0,amm->text,&ammr);
      tab->capminw=ammr.minwidth;
      tab->capmaxw=ammr.width;
      tab->capstate=TABRS_MEASURED;
   }

   /* Measure each table cell. Compute column dimensions from nonspanning cells.
    * If incremental measure, only measure new complete rows.
    * Set column dimensions always, since a cell may have become smaller. */
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next;tc=tc->next)
      {  if(tc->body)
         {  if(tr->state==TABRS_COMPLETE || (all && tr->state>TABRS_COMPLETE))
            {  if(tc->flags&TABCF_NOWRAP) mlf=AMMF_NOWRAP;
               else mlf=0;
               memset(&ammr,0,sizeof(ammr));
               Ameasure(tc->body,amm->width,amm->height,0,mlf,amm->text,&ammr);
               /* Dirty hack - set width to >=1 to prevent table collapse */
               tc->minw=MAX(1,ammr.minwidth);
               tc->maxw=MAX(1,ammr.width);
            }
            if(tc->colspan==1)
            {  hcol=&tab->cols[tc->cellnr-1];
               if(tc->maxw>hcol->maxw) hcol->maxw=tc->maxw;
               if(tc->minw>hcol->minw)
               {  hcol->minw=tc->minw;
               }
               if(tc->swtype && !hcol->swtype)
               {  hcol->swidth=tc->swidth;
                  hcol->swtype=tc->swtype;
               }
               if(hcol->swtype==SWT_PIXELS)
               {  if(hcol->swidth>hcol->minw) hcol->maxw=hcol->swidth;
                  else hcol->maxw=hcol->minw;
               }

               hcol->flags |= (TABCF_BORLEFT & tc->flags);
               hcol->flags |= (TABCF_BORRIGHT & tc->flags);

            }
         }
      }
      if(tr->state==TABRS_COMPLETE || (all && tr->state>TABRS_COMPLETE))
      {  tr->state=TABRS_MEASURED;
      }
   }

#if 0
/* This is optional - include code to inhibit incremental display
   for tables containing unsized columns*/

   /* Disallow incremental display if a column is unsized */
   if(tab->flags&TABF_INCREMENTAL)
   {  for(i=0;i<tab->nrcols;i++)
      {  if(!tab->cols[i].swtype)
         {  tab->flags&=~TABF_INCREMENTAL;
            if(!(tab->flags&TABF_COMPLETE)) return 0;
         }
      }
   }

/*   end optional code. */
#endif

   /* Distribute width of spanning cells over the spanned columns */
   /* Distribution of max width is proportional.
    * Distribution of min size is proportional over the difference between
    * the cell's max and min sizes (unless this difference is zero,
    * then use min widths).
    *
    * tc->minw, tc->maxw is size to distribute.
    * tcminw,tcmaxw is what is left of target widths after assigning each column.
    *    Remainder due to rounding errors is added to the first column.
    * minw,maxw is what is left of total old min/max size of spanned columns
    *    after assigning each column.
    * dw is maxw-minw of remaining columns.
    * tcdw is tcminw-minw of remaining columns.
    */
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next;tc=tc->next)
      {  if(tc->body && tc->colspan>1)
         {  minw=0;maxw=0;
            n=tc->cellnr-1;
            for(i=0;i<tc->colspan;i++)
            {  minw+=tab->cols[n+i].minw;
               maxw+=tab->cols[n+i].maxw;
            }
            tcminw=tc->minw;
            tcmaxw=tc->maxw;
            for(i=0;i<tc->colspan;i++)
            {  hcol=&tab->cols[n+i];
               dw=maxw-minw;
               tcdw=tcminw-minw;

               old=hcol->minw;
               if(tcdw>0)
               {  if(dw>0) hcol->minw+=(hcol->maxw-hcol->minw)*tcdw/dw;
                  else if(minw>0) hcol->minw=hcol->minw*tcminw/minw;
                  else hcol->minw=tcminw/tc->colspan;
               }
               minw-=old;
               tcminw-=hcol->minw;

               old=hcol->maxw;
               if(maxw<tcmaxw)
               {  if(maxw>0) hcol->maxw=hcol->maxw*tcmaxw/maxw;
                  else hcol->maxw=tc->maxw/tc->colspan;
               }
               maxw-=old;
               tcmaxw-=hcol->maxw;

               /* set border flags for far left and right cols */
               if (i==0)
               {
                  hcol->flags |= (TABCF_BORLEFT & tc->flags);
               }
               if (i==tc->colspan-1)
               {
                  hcol->flags |= (TABCF_BORRIGHT & tc->flags);
               }
            }
            if(tcminw>0) tab->cols[n].minw+=tcminw;
            if(tcmaxw>0) tab->cols[n].maxw+=tcmaxw;

         }
      }
   }

   /* Compute the table dimensions. */
   /* table's minimum width is sum of all minimum widths.
    * table's maximum width is computed in steps:
    *  - Compute maximum of rel+unsized columns:
    *    = maximum of maxw * totalrel / columnrel per relsized column
    *    + minimum of unsized columns (rel sized are scaled relative to smallest
    *        in rel units)
    *    or: = maximum of unsized columns if there are no relative sized columns.
    *  - Assign percentage to rel+unsized columns.
    *  - Table max width = maximum of maxw * totalprc / columnprc per
    *       percentage sized column including the (rel+unsized) column set
    *       (Prc sized are scaled relative to smallest in %)
    *    + maxw of pixel sized columns.
    */
   tab->minw=tab->maxw=0;
   totalprc=0;
   totalrel=0;
   maxuns=minuns=minrel=0;
   /* Compute table minw, remember pixel sized maxw, remember total relative units
    * and total percentage, remember total minimum and maximum widths for unsized. */
   for(i=0;i<tab->nrcols;i++)
   {  hcol=&tab->cols[i];
      tab->minw+=hcol->minw;
      switch(hcol->swtype)
      {  case SWT_UNSIZED:
            minuns+=hcol->minw;
            maxuns+=hcol->maxw;
            break;
         case SWT_PIXELS:
            tab->maxw+=hcol->maxw;
            break;
         case SWT_PERCENT:
            totalprc+=hcol->swidth;
            break;
         case SWT_RELATIVE:
            totalrel+=hcol->swidth;
            minrel+=hcol->minw;
            break;
      }
   }
   /* Compute maximum of rel + unsized columns */
   if(totalrel)
   {  maxruw=0;
      for(i=0;i<tab->nrcols;i++)
      {  hcol=&tab->cols[i];
         if(hcol->swtype==SWT_RELATIVE)
         {  w=hcol->maxw*totalrel/hcol->swidth;
            if(w>maxruw) maxruw=w;
         }
      }
      maxruw+=minuns;
   }
   else
   {  maxruw=maxuns;
   }
   /* Assign percentage to rel + unsized columns */
   if(totalprc<100)
   {  ruprc=100-totalprc;
      totalprc=100;
   }
   else ruprc=0;
   /* Compute maximum size of relative sized columns. First the rel+unsized. */
   maxw=0;
   if(maxruw)
   {  if(ruprc>0)
      {  w=maxruw*totalprc/ruprc;
         if(w>maxw) maxw=w;
      }
      else tab->maxw+=minuns+minrel;
   }
   for(i=0;i<tab->nrcols;i++)
   {  hcol=&tab->cols[i];
      if(hcol->swtype==SWT_PERCENT)
      {  w=hcol->maxw*totalprc/hcol->swidth;
         if(w>maxw) maxw=w;
      }
   }
   tab->maxw+=maxw;

   /* FIXME: do I need to do this every time ? */

   tab->nvrules = 0;
   for(i=0;i<tab->nrcols;i++)
   {
      hcol=&tab->cols[i];
      if(hcol->flags & TABCF_BORLEFT) tab->nvrules++;
      if(hcol->flags & TABCF_BORRIGHT) tab->nvrules++;

   }

   tab->minw+=(tab->nrcols + 1)*tab->spacing + tab->nvrules;
   tab->maxw+=(tab->nrcols + 1)*tab->spacing + tab->nvrules;


   minw=tab->minw;
   maxw=tab->maxw;
   if(tab->caption)
   {  if(tab->capminw>minw) minw=tab->capminw;
      if(tab->capmaxw>maxw) maxw=tab->capmaxw;
   }
   tab->minw+=tab->borleft+tab->borright;
   tab->maxw+=tab->borleft+tab->borright;
   minw+=tab->borleft+tab->borright;
   maxw+=tab->borleft+tab->borright;
   if((tab->flags&TABF_PIXELS) && tab->width>maxw) maxw=tab->maxw=tab->width;

   if((tab->flags&TABF_PIXELS) && tab->width>minw) minw=tab->minw=(tab->width +tab->borleft +tab->borright);
   if(maxw < minw) maxw = tab->minw = minw ;
   if(amm->ammr)
   {  amm->ammr->width=maxw;
      amm->ammr->minwidth=minw;
      amm->ammr->newline=TRUE;
   }


   return 0;
}

static long Layouttable(struct Table *tab,struct Amlayout *aml)
{  struct Tabrow *tr,*trs;
   struct Tabcell *tc;
   short i;
   long height,sheight = 0,w,d,toth,lefth,desw,spacing,bloffset,winweb,minw,maxw,h;
   long minpix,sizepix,minprc,totalprc,minrel,totalrel,minuns,maxuns;
   long ruprc,tw;
   BOOL allfit;
   struct Tabcol *hcol;
   UWORD mlf;
   struct Amlresult amlr={0};
   BOOL all;
   short *oldwidths=NULL;

   /* In case of RETRY, don't do anything if we are aligned. */
   if((aml->flags&AMLF_RETRY) && (tab->elt.eltflags&ELTF_ALIGNED))
   {  if(aml->amlr)
      {  aml->amlr->result=AMLR_OK;
         aml->amlr->endx=aml->startx;
      }
      return 0;
   }

   if(aml->flags&AMLF_BREAK)
   {  if(aml->amlr) aml->amlr->result=AMLR_OK;
      return 0;
   }

   tab->elt.aox=aml->startx;
   /* If incomplete and no incremental display, do nothing. */
   if(!prefs.browser.inctable) tab->flags&=~TABF_INCREMENTAL;
   if(!(tab->flags&(TABF_INCREMENTAL|TABF_COMPLETE)))
   {  if(aml->amlr)
      {  aml->amlr->result=AMLR_NEWLINE;
         aml->amlr->endx=tab->elt.aox;
      }
      return 0;
   }

   /* Layout all if requested,
    * or if no incremental display is allowed and table is complete. */
   all=!(aml->flags&AMLF_CHANGED) || (aml->flags&AMLF_FORCE)
      || !(tab->flags&TABF_INCREMENTAL);
   if(all)
   {  tab->flags&=~(TABF_LAYEDOUT|TABF_BBLAYEDOUT);
      if(tab->capstate>TABRS_MEASURED) tab->capstate=TABRS_MEASURED;
   }
   else
   {  /* Do relayout the bottom things */
      tab->flags&=~TABF_BBLAYEDOUT;
      if(tab->flags&TABF_CAPBOTTOM)
      {  if(tab->capstate>TABRS_MEASURED) tab->capstate=TABRS_MEASURED;
      }
   }

   /* Do nothing if not at least one row to layout */
   if(!(tab->rows.first->next && tab->rows.first->state))
   {  if(aml->amlr)
      {  aml->amlr->result=AMLR_NEWLINE;
         aml->amlr->endx=tab->elt.aox;
      }
      return 0;
   }

   /* If we are forced, then it means we are wider than the window.
    * This means we are bound to be called over and over again with
    * the AMLF_FORCE flag set. To prevent repetitive full table layouts,
    * inhibit incremental display now. */
   if(aml->flags&AMLF_FORCE)
   {  tab->flags&=~(TABF_INCREMENTAL);
   }

   /* tab->minw,maxw is inclusive spacing and inclusive outer borders
      (local) minw,maxw is inclusive spacing and exclusive outer borders
      aml->width is inclusive spacing of course and inclusive outer borders
            and inclusive aml->startx
      winweb, desw is inclusive spacing and exclusive outer borders
      hcol->minw,maxw,width is exclusive spacing
    */
   spacing=(tab->nrcols + 1)*tab->spacing;
   winweb=(aml->width-aml->startx)-tab->borleft-tab->borright;
   minw=tab->minw-tab->borleft-tab->borright;
   maxw=tab->maxw-tab->borleft-tab->borright;

   /* determine desired width of table excluding borders */
   if(tab->width)
   {  if(tab->flags&TABF_PIXELS) desw=tab->width;
      else desw=(aml->width-aml->startx)*tab->width/100-tab->borleft-tab->borright;
      if(desw>winweb) desw=winweb;  /* do not cross borders */
      if(desw<minw) desw=minw;
   }
   else if(tab->caption && tab->capmaxw>maxw)
   {  /* caption is wider than table, scale to caption width */
      if(tab->capminw>winweb) desw=tab->capminw;
      else if(tab->capmaxw<winweb) desw=tab->capmaxw;
      else desw=winweb;
   }
   else
   {  if(minw>winweb) desw=minw;
      else if(maxw<winweb) desw=maxw;
      else desw=winweb;
   }


   /* In case of incremental layout, remember old column widths.
    * If the relayout results in different widths, relayout the entire table
    * after all, else only layout the added rows. */
   if(!all)
   {  oldwidths=PALLOCTYPE(short,tab->nrcols,0,tab->pool);
      if(oldwidths)
      {  for(i=0;i<tab->nrcols;i++)
         {  oldwidths[i]=tab->cols[i].width;
         }
      }
   }

/*
Table layout algorythm used here:

- Pixel sized columns.
  If minimum cell width > suggested width, use minimum width instead.
  If table is too narrow to accomodate suggested pixel widths plus
  minimum width of other columns, assign other columns their minimum
  widths and divide remaining space over pixel sized columns.
  Else assign pixel sized columns their suggested width.

- Percentage sized columns.
  If total percentage < 100, assign the remaining percentage to the
  other columns together if there are any.
  Do while not all percentage sized columns have a width assigned,
  for all columns including total of other columns:
  - Compute resulting width from percentage and remaining space.
    If resulting width less than minimum width, assign minimum width
    and adjust remaining percentage.
  For all columns (including "other columns" together) that haven't
  got a width assigned yet, assign the resulting width from their
  percentage and the remaining space.

- Now either relative sized or unsized columns should remain (if any).
  In case both are present, assign unsized columns their minimum width.

- Relative sized columns.
  Do while not all relative sized columns have a width assigned,
  for all columns:
  - Compute resulting width from relative size and remaining space.
    If resulting width less than minimum width, assign minimum width
    and adjust remaining relative units.
  For all columns that haven't got a width assigned yet, assign the
  resulting width from their relative size and the remaining space.

- Unsized columns.
  If unsized columns haven't got a width assigned (if they have, it's
  their minimum width), distribute them into the remaining space,
  weighted by their minimum and maximum widths.

*/

   /* assign column widths.
    *
    * minpix = minimum width of columns with pixel size
    * sizepix = suggested width of columns with pixel size
    * minprc = minimum width of columns with percentage
    * totalprc = total (remaining) percentage
    * minrel = minimum width of relative sized columns
    * totalrel = total (remaining) relative units
    * minuns = minimum width of unsized columns
    * maxuns = maximum width of unsized columns
    * ruprc = percentage remaining for relative and unsized columns together
    * tw = remaining table width to divide excluding spacing amd vrules
    *
    * first, compute these numbers and reset the column widths. */

   minpix=sizepix=minprc=totalprc=minrel=totalrel=minuns=maxuns=0;

   tw=desw - (tab->nrcols +1) * tab->spacing - tab->nvrules;
   for(i=0;i<tab->nrcols;i++)
   {  hcol=&tab->cols[i];
      switch(hcol->swtype)
      {  case SWT_UNSIZED:
            minuns+=hcol->minw;
            maxuns+=hcol->maxw;
            break;
         case SWT_PIXELS:
            minpix+=hcol->minw;
            sizepix+=MAX(hcol->minw,hcol->swidth);
            break;
         case SWT_PERCENT:
            minprc+=hcol->minw;
            totalprc+=hcol->swidth;
            break;
         case SWT_RELATIVE:
            minrel+=hcol->minw;
            totalrel+=hcol->swidth;
            break;
      }
      hcol->width=0;
   }
   if(minuns+minrel)
   {  /* there are unsized or relative sized columns,
       * assign those the remaining percentage */
      if(totalprc>100) ruprc=0;
      else ruprc=100-totalprc;
      totalprc+=ruprc;
   }
   else ruprc=0;
   /* If table is minimum width, use minimum width for all columns */
   /* Don't do this if minimum width was set by suggested width of table */
   if((tw<=(minw-(tab->nrcols +1)*tab->spacing)-tab->nvrules) && (minw!=tab->width))
   {  for(i=0;i<tab->nrcols;i++)
      {  hcol=&tab->cols[i];
         hcol->width=hcol->minw;
      }
      /* we're done */
   }
   else
   {  /* If there is not enough room for pixel sized columns plus minimum of others,
       * assign minimum width to others and divide remaining space over pixel sized
       * columns */
      if(sizepix+minprc+minrel+minuns>=tw)
      {  w=tw-minprc-minrel-minuns-minpix;   /* extra width to divide */
         d=sizepix-minpix;                   /* extra width wanted */
         for(i=0;i<tab->nrcols;i++)
         {  hcol=&tab->cols[i];
            if(hcol->swtype==SWT_PIXELS)
            {  if(d && hcol->swidth>hcol->minw)
               {  hcol->width=hcol->minw+(hcol->swidth-hcol->minw)*w/d;
               }
               else hcol->width=hcol->minw;
            }
            else
            {  hcol->width=hcol->minw;
            }
         }
         /* we're done */
      }
      else
      {  /* There is enough room for the pixel sized columns.
          * Assign their widths now.
          * If there are no other columns, expand them as necessary. */
         for(i=0;i<tab->nrcols;i++)
         {  hcol=&tab->cols[i];
            if(hcol->swtype==SWT_PIXELS)
            {  hcol->width=MAX(hcol->minw,hcol->swidth);
               if(!minprc && !minrel && !minuns && sizepix)
               {  hcol->width=hcol->width*(desw-(tab->nrcols +1)*tab->spacing-tab->nvrules)/sizepix;
               }
               tw-=hcol->width;
            }
         }
         /* For every percentage sized column, and total rel/unsized columns,
          * as long as it hasn't got a width assigned yet:
          * Check if minimum size fits in percentage of remaining width.
          * If not, assign minimum width to this column, and since this
          * changes the remaining width, start all over again. */
         allfit=FALSE;
         while(!allfit)
         {  allfit=TRUE;
            if((minuns+minrel)
            && (totalprc<=0 || (minuns+minrel)>tw*ruprc/totalprc))
            {  /* Relative and unsized don't fit, give them their minimum width. */
               for(i=0;i<tab->nrcols;i++)
               {  hcol=&tab->cols[i];
                  if(hcol->swtype==SWT_UNSIZED || hcol->swtype==SWT_RELATIVE)
                  {  hcol->width=hcol->minw;
                     tw-=hcol->width;
                  }
               }
               totalprc-=ruprc;
               minuns=minrel=0;   /* reset so we know it's assigned */
               allfit=FALSE;
               continue;   /* start all over again */
            }
            /* Check all unassigned percentage width columns */
            for(i=0;i<tab->nrcols;i++)
            {  hcol=&tab->cols[i];
               if(!hcol->width && hcol->swtype==SWT_PERCENT)
               {  if(totalprc<=0 || hcol->minw>tw*hcol->swidth/totalprc)   /* doesn't fit */
                  {  hcol->width=hcol->minw;
                     tw-=hcol->width;
                     totalprc-=hcol->swidth;
                     allfit=FALSE;
                     break;   /* start all over again */
                  }
               }
            }
         }
         /* Assign the unassigned percentage sized columns their widths
          * computed from the original remaining table width (w). */
         w=tw;
         for(i=0;i<tab->nrcols;i++)
         {  hcol=&tab->cols[i];
            if(!hcol->width && hcol->swtype==SWT_PERCENT)
            {  if(totalprc>0) hcol->width=w*hcol->swidth/totalprc;
               else hcol->width=hcol->minw;
               tw-=hcol->width;
            }
         }
         /* If both relative and unsized columns exist, assign the unsized
          * columns their minimum widths */
         if(minrel && minuns)
         {  for(i=0;i<tab->nrcols;i++)
            {  hcol=&tab->cols[i];
               if(!hcol->width && hcol->swtype==SWT_UNSIZED)
               {  hcol->width=hcol->minw;
                  tw-=hcol->width;
               }
            }
            minuns=0;
         }
         /* For every relative sized column, as long as it hasn't got a width
          * assigned yet:
          * Check if minimum size fits in relative part of remaining width.
          * If not, assign the minimum width to this column, and since this
          * changes the remaining width, start all over again. */
         allfit=FALSE;
         while(!allfit)
         {  allfit=TRUE;
            for(i=0;i<tab->nrcols;i++)
            {  hcol=&tab->cols[i];
               if(!hcol->width && hcol->swtype==SWT_RELATIVE)
               {  if(totalrel<=0 || hcol->minw>tw*hcol->swidth/totalrel)   /* doesn't fit */
                  {  hcol->width=hcol->minw;
                     tw-=hcol->width;
                     totalrel-=hcol->swidth;
                     allfit=FALSE;
                     break;   /* start all over again */
                  }
               }
            }
         }
         /* Assign the unassigned relative sized columns their widths
          * computed from the original remaining table width (w). */
         w=tw;
         for(i=0;i<tab->nrcols;i++)
         {  hcol=&tab->cols[i];
            if(!hcol->width && hcol->swtype==SWT_RELATIVE)
            {  if(totalrel>0) hcol->width=w*hcol->swidth/totalrel;
               else hcol->width=hcol->minw;
               tw-=hcol->width;
            }
         }
         /* Now there is enough space for all unassigned columns.
          * Distribute weighted by their minimum and maximum widths */
         if(minuns)  /* unsized width columns are not yet assigned a width */
         {  w=tw-minuns;            /* extra width to distribute */
            d=maxuns-minuns;        /* extra size wanted */
            for(i=0;i<tab->nrcols;i++)
            {  hcol=&tab->cols[i];
               if(hcol->swtype==SWT_UNSIZED)
               {  if(maxuns>tw)     /* shrink column */
                  {  if(d) hcol->width=hcol->minw+(hcol->maxw-hcol->minw)*w/d;
                     else hcol->width=hcol->minw;
                  }
                  else if(maxuns>0) /* expand column */
                  {  hcol->width=hcol->maxw*tw/maxuns;
                  }
               }
            }
         }
         /* we're done */
      }
   }

   /* If incremental layout: check the new column widths against the old ones. */
   if(oldwidths)
   {  for(i=0;i<tab->nrcols;i++)
      {  if(oldwidths[i] && tab->cols[i].width!=oldwidths[i])
         {  all=TRUE;
            tab->flags&=~(TABF_LAYEDOUT|TABF_BBLAYEDOUT);
            tab->capstate=TABRS_MEASURED;
            break;
         }
      }
      FREE(oldwidths);

#if 0
/* Another optional part - stop incremental display if relayout needed. */


      if(all && !(tab->flags&TABF_COMPLETE))
      {  /* Columns are resized; stop incremental display now. */
         tab->flags&=~TABF_INCREMENTAL;
         if(aml->amlr)
         {  aml->amlr->result=AMLR_NEWLINE;
            aml->amlr->endx=tab->elt.aox;
         }
         return 0;
      }

  /* End optional code */
#endif
   }

   /* compute the resulting position for all columns, and table width (incl left border): */
   if(!(tab->flags&TABF_LAYEDOUT))
   {  tab->elt.aow=tab->borleft + tab->spacing;
      for(i=0;i<tab->nrcols;i++)
      {
         if(tab->cols[i].flags & TABCF_BORLEFT) tab->elt.aow++;
         tab->cols[i].x=tab->elt.aow;
         tab->elt.aow+=tab->cols[i].width+tab->spacing;
         if(tab->cols[i].flags & TABCF_BORRIGHT) tab->elt.aow++;
      }
   }

   /* Layout the individual cells. Compute row height from single row spanning cells */
   if(tab->caption && tab->capstate==TABRS_MEASURED)
   {  Alayout(tab->caption,tab->elt.aow-tab->borleft,aml->height,0,aml->text,0,NULL);
   }
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  if(tr->state==TABRS_MEASURED || (all && tr->state>TABRS_MEASURED))
      {  tr->height=0;
         tr->baseline=0;

         /* must reset the border flags for the row here as they can change as the */
         /* table is built FIXME: do I need to do this if incremental tables is off ? */

         tr->flags &= ~TABRF_BORTOP;
         tr->flags &= ~TABRF_BORBOTTOM;

         for(tc=tr->cells.first;tc->next;tc=tc->next)
         {
            /* if this cell has rules top or bottom set the row flag accordingly */

            if(tc->flags & TABCF_BORTOP) tr->flags |= TABRF_BORTOP;
            if(tc->flags & TABCF_BORBOTTOM) tr->flags |= TABRF_BORBOTTOM;

            if(tc->body)
            {  tc->x=tab->cols[tc->cellnr-1].x /* +tab->spacing/2 */;
               hcol=&tab->cols[tc->cellnr-1];
               tc->width=(tc->colspan-1)*tab->spacing;
               for(i=0;i<tc->colspan;i++,hcol++) tc->width+=hcol->width;
         //      if(tab->border) tc->width+= 2*(tc->colspan-1);

               if(tc->flags&TABCF_NOWRAP) mlf=AMLF_NOWRAP;
               else mlf=0;
               amlr.above=0;
               Alayout(tc->body,tc->width,aml->height,mlf|AMLF_INTABLE,aml->text,0,&amlr);
               tc->baseline=amlr.above;
               if(tc->valign==VALIGN_BASELINE)
               {  if(tc->baseline>tr->baseline) tr->baseline=tc->baseline;
               }
            }
         }
         for(tc=tr->cells.first;tc->next;tc=tc->next)
         {  if(tc->body)
            {  if(tc->rowspan==1)
               {  if(tc->valign==VALIGN_BASELINE)
                  {  bloffset=tr->baseline-tc->baseline;
                     if(bloffset) Amove(tc->body,0,bloffset);
                  }
                  else bloffset=0;
                  height=bloffset+Agetattr(tc->body,AOBJ_Height);
                  if(tc->shtype)
                  {  if(tc->shtype==SWT_PERCENT)
                     {  if(!(aml->flags&AMLF_INTABLE)) sheight=((long)tc->sheight)*aml->height/100;
                     }
                     else sheight=(long)tc->sheight;
                     if(sheight>height) height=sheight;
                  }
                  if(height>tr->height) tr->height=height;
               }
            }
         }
         tr->state=TABRS_LAYEDOUT;
      }
   }
   /* Compute resulting row heights, incorporating rowspans.
      If cell spans >1 row, scale this and following row heights if necessary */
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  if(tr->state==TABRS_LAYEDOUT)
      {  for(tc=tr->cells.first;tc->next;tc=tc->next)
         {  if(tc->body)
            {  if(tc->rowspan>1)
               {  /* distribute excess height over spanned rows.
                   * height = spanning cells height
                   * toth = total spanned cells height
                   * lefth = height left, remaninder is added to last row */
                  if(tc->valign==VALIGN_BASELINE)
                  {  bloffset=tr->baseline-tc->baseline;
                     if(bloffset) Amove(tc->body,0,bloffset);
                  }
                  else bloffset=0;
                  lefth=height=bloffset+Agetattr(tc->body,AOBJ_Height);
                  if(tc->shtype)
                  {  if(tc->shtype==SWT_PERCENT)
                     {  if(!(aml->flags&AMLF_INTABLE)) sheight=((long)tc->sheight)*aml->height/100;
                     }
                     else sheight=(long)tc->sheight;
                     if(sheight>height) height=sheight;
                  }
                  toth=0;
                  for(trs=tr,i=0;i<tc->rowspan;trs=trs->next,i++) toth+=trs->height;
                  if(toth<height)
                  {  for(trs=tr,i=0;i<tc->rowspan;trs=trs->next,i++)
                     {  if(toth) trs->height=trs->height*height/toth;
                        else trs->height=height/tc->rowspan;
                        lefth-=trs->height;
                     }
                     if(lefth>0) trs->prev->height+=lefth;
                  }
               }
            }
         }
      }
   }
   /* Fix cell positions */
   if(!(tab->flags&TABF_LAYEDOUT))
   {  tab->elt.aoh=tab->bortop +tab->spacing;
      tab->incrementaly=0;
   }
   if(tab->capstate==TABRS_MEASURED
   && (tab->caption && !(tab->flags&TABF_CAPBOTTOM)))
   {  Amove(tab->caption,tab->elt.aox+tab->borleft,tab->elt.aoh);
      tab->elt.aoh+=Agetattr(tab->caption,AOBJ_Height);
      tab->capstate=TABRS_LAYEDOUT;
   }
   for(tr=tab->rows.first;tr->next;tr=tr->next)
   {  if(tr->state==TABRS_LAYEDOUT)
      {
         if(tr->flags & TABRF_BORTOP) tab->elt.aoh++;
         tr->y=tab->elt.aoh;
         for(tc=tr->cells.first;tc->next;tc=tc->next)
         {
            if(tc->body)
            {  tc->y=tab->elt.aoh /*+tab->spacing/2 */;
               Amove(tc->body,tab->elt.aox+tc->x,tc->y);
               if(tc->rowspan==1) tc->height=tr->height;
               else
               {  tc->height=(tc->rowspan-1)*tab->spacing;
                  for(trs=tr,i=0;i<tc->rowspan;trs=trs->next,i++) tc->height+=trs->height;
               }
               switch(tc->valign)
               {  case VALIGN_TOP:
                     tc->dy=0;
                     break;
                  case VALIGN_BOTTOM:
                     h=Agetattr(tc->body,AOBJ_Height);
                     tc->dy=tc->height-h;
                     Amove(tc->body,0,tc->height-h);
                     break;
                  case VALIGN_MIDDLE:
                     h=Agetattr(tc->body,AOBJ_Height);
                     tc->dy=(tc->height-h)/2;
                     Amove(tc->body,0,(tc->height-h)/2);
                     break;
               }
            }
         }
         tab->elt.aoh+=tr->height+tab->spacing;
         if(tr->flags & TABRF_BORBOTTOM) tab->elt.aoh++;
      }
   }
   if((tab->flags&TABF_COMPLETE)
   && tab->capstate==TABRS_MEASURED
   && tab->caption && (tab->flags&TABF_CAPBOTTOM))
   {  Amove(tab->caption,tab->elt.aox+tab->borleft,tab->elt.aoh);
      tab->elt.aoh+=Agetattr(tab->caption,AOBJ_Height);
      tab->capstate=TABRS_LAYEDOUT;
   }
   /* complete border around table */
   if(!(tab->flags&TABF_LAYEDOUT) && tab->border)
   {  tab->elt.aow+=tab->borright;
   }
   if((tab->flags&TABF_COMPLETE) && !(tab->flags&TABF_BBLAYEDOUT))
   {  tab->elt.aoh+=tab->borbottom;
      tab->flags|=TABF_BBLAYEDOUT;
   }
   tab->flags|=TABF_LAYEDOUT;

   return (long)AmethodasA(AOTP_ELEMENT,(struct Aobject *)tab,(struct Amessage *)aml);
}

static long Aligntable(struct Table *tab,struct Amalign *ama)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   struct Ammove amm={{0}};
   if((tab->flags&TABF_INCREMENTAL) || !(tab->elt.eltflags&ELTF_ALIGNED))
   {  amm.amsg.method=AOM_MOVE;
      amm.dx=ama->dx;
      amm.dy=ama->y;
      for(tr=tab->rows.first;tr->next;tr=tr->next)
      {  if(tr->state==TABRS_LAYEDOUT)
         {  for(tc=tr->cells.first;tc->next;tc=tc->next)
            {  if(tc->body)
               {  AmethodA(tc->body,(struct Amessage *)&amm);
               }
            }
            tr->state=TABRS_ALIGNED;
         }
      }
      if(tab->caption && tab->capstate==TABRS_LAYEDOUT)
      {  AmethodA(tab->caption,(struct Amessage *)&amm);
         tab->capstate=TABRS_ALIGNED;
      }
   }
   if(!(tab->elt.eltflags&ELTF_ALIGNED))
   {  tab->elt.aox+=ama->dx;
      tab->elt.aoy=ama->y;
      tab->elt.eltflags|=ELTF_ALIGNED;
   }
   return 0;
}

static long Rendertable(struct Table *tab,struct Amrender *amr)
{  struct Coords *coo,coords={0};
   BOOL clip=FALSE;
   ULONG clipkey=0;
   struct RastPort *rp;
   long x,y;
   struct Tabrow *tr;
   struct Tabcell *tc;
   BOOL all;
   tab->elt.bgupdate = bgupdate;

   all=!(amr->flags&AMRF_CHANGED) || !(tab->flags&TABF_INCREMENTAL)
      || (amr->flags&AMRF_CLEARBG);
   if(!(tab->flags&(TABF_INCREMENTAL|TABF_COMPLETE))) return 0;
   if(!(tab->flags&TABF_LAYEDOUT)) return 0;

   if(!(amr->flags&(AMRF_UPDATESELECTED|AMRF_UPDATENORMAL)))
   {  if(!(coo=amr->coords))
      {  Framecoords(tab->elt.cframe,&coords);
         coo=&coords;
         clip=TRUE;
      }
      if(coo->rp)
      {
         short save_bgcolor=coo->bgcolor;
         void *save_bgimage=coo->bgimage;

         if(prefs.browser.docolors &&(tab->bgcolor || tab->bgimage))
         {
             if(tab->bgcolor) coo->bgcolor=COLOR(tab->bgcolor);
             coo->bgimage=tab->bgimage;
             coo->bgalign=tab->bgalign;

             Erasebg(tab->frame,coo,
                MAX( amr->rect.minx, tab->elt.aox),
                MAX( amr->rect.miny, tab->elt.aoy),
                MIN( amr->rect.maxx, tab->elt.aox + tab->elt.aow - 1),
                MIN( amr->rect.maxy, tab->elt.aoy + tab->elt.aoh - 1) );
         }

         rp=coo->rp;
         if(clip) clipkey=Clipto(rp,coo->minx,coo->miny,coo->maxx,coo->maxy);
         if(tab->caption
         && (tab->capstate==TABRS_ALIGNED || (all && tab->capstate>TABRS_ALIGNED)))
         {  Arender(tab->caption,coo,amr->rect.minx,amr->rect.miny,amr->rect.maxx,amr->rect.maxy,
               amr->flags&AMRF_NOTEMPRAST /* amr->flags|AMRF_CLEARBG but amr->minx etc must be clipped */ ,amr->text);
            tab->capstate=TABRS_RENDERED;
         }



         for(tr=tab->rows.first;tr->next;tr=tr->next)
         {  if(tr->state==TABRS_ALIGNED || (all && tr->state>TABRS_ALIGNED))
            {
               for(tc=tr->cells.first;tc->next;tc=tc->next)
               {  if(tc->body)
                  {  x=tab->elt.aox+tc->x;
                     y=tab->elt.aoy+tc->y;
                     if(x<=amr->rect.maxx && x+tc->width>amr->rect.minx
                     && y<=amr->rect.maxy && y+tc->height>amr->rect.miny)

                     {
                          Arender(tc->body,coo,
                           MAX(amr->rect.minx,x),
                           MAX(amr->rect.miny,y),
                           MIN(amr->rect.maxx,x+tc->width-1),
                           MIN(amr->rect.maxy,y+tc->height-1),
                           amr->flags&(AMRF_CLEARBG|AMRF_NOTEMPRAST|AMRF_CLEAR),amr->text);
                     }
                  }
                  if(tab->rules)
                  {  Rendercellborder(tab,coo,tr,tc);
                  }
               }
               tr->state=TABRS_RENDERED;
            }
         }
         if(tab->border && tab->tabframe)
         {  Rendertabframe(tab,coo);
         }
         if(clip) Unclipto(clipkey);
         tab->incrementaly=tab->elt.aoh;

         coo->bgcolor=save_bgcolor;
         coo->bgimage=save_bgimage;

      }
   }
   return 0;
}

static long Settable(struct Table *tab,struct Amset *ams)
{  long result;
   struct TagItem *tag,*tstate=ams->tags;
   BOOL done=FALSE,newcframe=FALSE,newframe=FALSE,newwin=FALSE,newwhis=FALSE;
   void *winhis=NULL;
   long vspacing=0;
   result=Amethodas(AOTP_ELEMENT,tab,AOM_SET,(Tag)ams->tags);
   while(!done && (tag=NextTagItem(&tstate)))
   {  switch(tag->ti_Tag)
      {  case AOBJ_Pool:
            tab->pool=(void *)tag->ti_Data;
            break;
         case AOBJ_Cframe:
            /* allready set in element above*/
            newcframe=TRUE;
            break;
         case AOBJ_Frame:
            if(tab->frame!=(void *)tag->ti_Data)
            {
                tab->frame=(void *)tag->ti_Data;
                newframe=TRUE;
            if(tab->bgimage)
            {
                void *framecopy;
                struct Document *doc;
                struct Bguser   *bgu = NULL;
                struct Bgimage  *bgi;

                /* get the document we belong too ... */
                /* but abort if we sometimes don't have a frame */

                if(tab->frame)
                {
                    framecopy = (void *)Agetattr((struct Aobject*)tab->frame,AOFRM_Copy);
                    doc  = (struct Document *)Agetattr((struct Aobject*)framecopy,AOCPY_Driver);
                    for(bgi=doc->bgimages.first;bgi->next;bgi=bgi->next)
                    {
                        if(tab->bgimage == bgi->copy)
                        {
                            if((bgu = ALLOCSTRUCT(Bguser,1,MEMF_CLEAR)))
                            {
                                bgu->user = tab;
                                ADDTAIL(&bgi->bgusers,bgu);
                            }
                            break;
                        }
                    }
                }


            }

            }
            break;
         case AOBJ_Window:

            if(tab->win != (void *)tag->ti_Data)
            {
                tab->win=(void *)tag->ti_Data;
                newwin=TRUE;
            }

            break;
         case AOBJ_Winhis:
            winhis=(void *)tag->ti_Data;
            newwhis=TRUE;
            break;
         case AOBJ_Layoutparent:
            tab->parent=(void *)tag->ti_Data;
            break;
         case AOBJ_Nobackground:
            SETFLAG(tab->flags,TABF_NOBACKGROUND,tag->ti_Data);
            break;
         case AOBJ_Changedchild:
            Resetrowstate(tab,((struct Element *)tag->ti_Data)->aoy);
            Asetattrs(tab->parent,AOBJ_Changedchild,(Tag)tab,TAG_END);
            break;
         case AOTAB_Percentwidth:
            tab->width=MAX(1,(short)tag->ti_Data);
            tab->flags&=~TABF_PIXELS;
            break;
         case AOTAB_Pixelwidth:
            tab->width=MAX(1,(short)tag->ti_Data);
            tab->flags|=TABF_PIXELS;
            break;
         case AOTAB_Border:
            tab->border=MAX(0,(short)tag->ti_Data);
            break;
         case AOTAB_Cellspacing:
            tab->spacing=MAX(0,(short)tag->ti_Data);
            break;
         case AOTAB_Cellpadding:
            tab->padding=MAX(0,(short)tag->ti_Data);
            break;
         case AOTAB_Caption:
            if(tag->ti_Data) done=Startcaption(tab,tstate,vspacing);
            else Endcaption(tab,vspacing);
            break;
         case AOTAB_Colgroup:
            if(tag->ti_Data) done=Startcolgroup(tab,tstate);
            else Endcolgroup(tab);
            break;
         case AOTAB_Column:
            done=Startcolumn(tab,tstate);
            break;
         case AOTAB_Thead:
         case AOTAB_Tbody:
            if(tag->ti_Data) done=Startrowgroup(tab,tstate);
            else Endrowgroup(tab);
            break;
         case AOTAB_Tfoot:
            if(tag->ti_Data) done=Starttfoot(tab,tstate);
            else Endrowgroup(tab);
            break;
         case AOTAB_Row:
            if(tag->ti_Data) done=Startrow(tab,tstate,vspacing);
            else Endrow(tab,vspacing);
            break;
         case AOTAB_Cell:
            if(tag->ti_Data) done=Startcell(tab,tstate,vspacing,FALSE);
            else Endcell(tab,vspacing);
            break;
         case AOTAB_Hcell:
            if(tag->ti_Data) done=Startcell(tab,tstate,vspacing,TRUE);
            else Endcell(tab,vspacing);
            break;
         case AOTAB_Endtable:
            Endtable(tab,vspacing);
            if(tab->elt.eltflags&ELTF_ALIGNED)
            {  /* If we are not yet aligned, this would cause body to re-layout
                * from 0 (since our aoy==0), and a relayout new is done anyway.
                * But: once we are aligned we must notify body. */
               Asetattrs(tab->parent,AOBJ_Changedchild,(Tag)tab,TAG_END);
            }
            break;
         case AOTAB_Vspacing:
            vspacing=tag->ti_Data;
            break;
         case AOTAB_Bgimage:
            tab->bgimage=(void *)tag->ti_Data;
            /* if it's our image align it to us */
            if(tab->bgimage)
            {
                tab->bgalign=(struct Aobject *)tab;
            }
            /* Since we now handle rendering of table wide background images at */
            /* Table level we must add ourselves as a "user" of that image */
            if(tab->bgimage)
            {
                void *framecopy;
                struct Document *doc;
                struct Bguser   *bgu;
                struct Bgimage  *bgi;

                /* get the document we belong too ... */
                /* but abort if we sometimes don't have a frame */

                if(tab->frame)
                {
                    framecopy = (void *)Agetattr((struct Aobject*)tab->frame,AOFRM_Copy);
                    doc  = (struct Document *)Agetattr((struct Aobject*)framecopy,AOCPY_Driver);
                    for(bgi=doc->bgimages.first;bgi->next;bgi=bgi->next)
                    {
                        if((void *)tag->ti_Data == bgi->copy)
                        {
                            if((bgu = ALLOCSTRUCT(Bguser,1,MEMF_CLEAR)))
                            {
                                bgu->user = tab;
                                ADDTAIL(&bgi->bgusers,bgu);
                            }
                            break;
                        }
                    }
                }



            }

            break;
         case AOTAB_Bgcolor:
            tab->bgcolor=(struct Colorinfo *)tag->ti_Data;
            break;
         case AOTAB_Bordercolor:
            tab->bordercolor=(struct Colorinfo *)tag->ti_Data;
            break;
         case AOTAB_Borderdark:
            tab->borderdark=(struct Colorinfo *)tag->ti_Data;
            break;
         case AOTAB_Borderlight:
            tab->borderlight=(struct Colorinfo *)tag->ti_Data;
            break;
         case AOTAB_Tabframe:
            tab->tabframe=tag->ti_Data;
            break;
         case AOTAB_Rules:
            tab->rules=tag->ti_Data;
            break;
      }
   }
   /*
   if(tab->rules && tab->spacing<2)
   {  tab->spacing=2;
   }
   */
   tab->borleft=(tab->tabframe&TABFRM_LEFT)?tab->border:0;
   tab->borright=(tab->tabframe&TABFRM_RIGHT)?tab->border:0;
   tab->bortop=(tab->tabframe&TABFRM_ABOVE)?tab->border:0;
   tab->borbottom=(tab->tabframe&TABFRM_BELOW)?tab->border:0;
   if(newcframe || newframe || newwin || newwhis)
   {  struct TagItem tags[5];
      struct Amset ams;
      tags[0].ti_Tag=(newcframe?AOBJ_Cframe:TAG_IGNORE);
      tags[0].ti_Data=(ULONG)tab->elt.cframe;
      tags[1].ti_Tag=(newwin?AOBJ_Window:TAG_IGNORE);
      tags[1].ti_Data=(ULONG)tab->win;
      tags[2].ti_Tag=(newframe?AOBJ_Frame:TAG_IGNORE);
      tags[2].ti_Data=(ULONG)tab->frame;
      tags[3].ti_Tag=(newwhis?AOBJ_Winhis:TAG_IGNORE);
      tags[3].ti_Data=(ULONG)winhis;
      tags[4].ti_Tag=TAG_END;
      ams.amsg.method=AOM_SET;
      ams.tags=tags;
      Broadcast(tab,(struct Amessage *)&ams);
   }
   /* change to not set colors when window is NULL */
   if(newwin && tab->win)
   {  Setcolors(tab);
   }
   return result;
}

static long Gettable(struct Table *tab,struct Amset *ams)
{  long result;
   struct TagItem *tag,*tstate=ams->tags;
   result=AmethodasA(AOTP_ELEMENT,(struct Aobject *)tab,(struct Amessage *)ams);
   while(tag=NextTagItem(&tstate))
   {  switch(tag->ti_Tag)
      {  case AOTAB_Body:
            PUTATTR(tag,Currentbody(tab,0));
            break;
         case AOTAB_Bodync:
            PUTATTR(tag,tab->curbody);
            break;
         case AOELT_Incrementaly:
            PUTATTR(tag,tab->incrementaly);
            break;
      }
   }
   return result;
}

static struct Table *Newtable(struct Amset *ams)
{  struct Table *tab;
   if(tab=Allocobject(AOTP_TABLE,sizeof(struct Table),ams))
   {  NEWLIST(&tab->rows);
      NEWLIST(&tab->tfoot);
      NEWLIST(&tab->coldefs);
      tab->spacing=2;
      tab->padding=2;
      tab->elt.valign=VALIGN_TOP;
      tab->rghalign=HALIGN_LEFT;
      tab->rgvalign=VALIGN_MIDDLE;
      Settable(tab,ams);
      /* Because of different AOM_ALIGN strategy, incremental can't be used for
       * floating tables. */
      if(prefs.browser.inctable
      && !(tab->elt.halign&(HALIGN_FLOATLEFT|HALIGN_FLOATRIGHT)))
      {  tab->flags|=TABF_INCREMENTAL;
      }
   }
   return tab;
}

static long Hittesttable(struct Table *tab,struct Amhittest *amh)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   long result=0;
   struct Coords *coo,coords={0};
   long x,y;
   if(!(coo=amh->coords))
   {  Framecoords(tab->elt.cframe,&coords);
      coo=&coords;
   }
   if(tab->caption)
   {  result=AmethodA(tab->caption,(struct Amessage *)amh);
   }
   for(tr=tab->rows.first;!result && tr->next;tr=tr->next)
   {  for(tc=tr->cells.first;!result && tc->next;tc=tc->next)
      {  x=amh->xco-tab->elt.aox-coo->dx;
         y=amh->yco-tab->elt.aoy-coo->dy;
         if(x>=tc->x && x<tc->x+tc->width && y>=tc->y && y<tc->y+tc->height)
         {  if(tc->body)
            {  result=AmethodA(tc->body,(struct Amessage *)amh);
               if(!result && tc->bgimage)
               {  result=AmethodA(tc->bgimage,(struct Amessage *)amh);
               }
            }
            return result;
         }
      }
   }
   return result;
}

static long Movetable(struct Table *tab,struct Ammove *amm)
{  tab->elt.aox+=amm->dx;
   tab->elt.aoy+=amm->dy;
   Broadcast(tab,(struct Amessage *)amm);
   return 0;
}

static long Notifytable(struct Table *tab,struct Amnotify *amn)
{  Broadcast(tab,(struct Amessage *)amn);
   return 0;
}

static long Searchpostable(struct Table *tab,struct Amsearch *ams)
{  return Broadcastnz(tab,(struct Amessage *)ams);
}

static long Searchsettable(struct Table *tab,struct Amsearch *ams)
{  return Broadcastnz(tab,(struct Amessage *)ams);
}

static long Dragtesttable(struct Table *tab,struct Amdragtest *amd)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   long result=0;
   long x,y;
   BOOL ok=FALSE;
   x=amd->xco-amd->coords->dx-tab->elt.aox;
   y=amd->yco-amd->coords->dy-tab->elt.aoy;
   if(tab->caption && !(tab->flags&TABF_CAPBOTTOM))
   {  result=AmethodA(tab->caption,(struct Amessage *)amd);
   }
   for(tr=tab->rows.first;tr->next && !result;tr=tr->next)
   {  for(tc=tr->cells.first;tc->next && !result;tc=tc->next)
      {  /* Start check with first cell that contains coordinates. */
         if(tc->x<=x && tc->x+tc->width>x && tc->y<=y && tc->y+tc->height>y) ok=TRUE;
         if(tc->body && ok)
         {  result=AmethodA(tc->body,(struct Amessage *)amd);
         }
      }
   }
   if(!result && tab->caption && (tab->flags&TABF_CAPBOTTOM))
   {  result=AmethodA(tab->caption,(struct Amessage *)amd);
   }
   if(!result)
   {  /* Pointer on table border */
      result=AMDR_STOP;
   }
   return result;
}

static long Dragrendertable(struct Table *tab,struct Amdragrender *amd)
{  Broadcast(tab,(struct Amessage *)amd);
   return 0;
}

static long Dragcopytable(struct Table *tab,struct Amdragcopy *amd)
{  Broadcast(tab,(struct Amessage *)amd);
   return 0;
}

static long Jsetuptable(struct Table *tab,struct Amjsetup *amj)
{  Broadcast(tab,(struct Amessage *)amj);
   return 0;
}

static void Disposetable(struct Table *tab)
{  struct Tabrow *tr;
   struct Tabcell *tc;
   struct Coldef *cd;
   while((tr=(struct Tabrow *)REMHEAD(&tab->rows)) || (tr=(struct Tabrow *)REMHEAD(&tab->tfoot)))
   {  while(tc=(struct Tabcell *)REMHEAD(&tr->cells))
      {  if(tc->body) Adisposeobject(tc->body);
         FREE(tc);
      }
      FREE(tr);
   }
   while(cd=(struct Coldef *)REMHEAD(&tab->coldefs))
   {  FREE(cd);
   }
   if(tab->caption) Adisposeobject(tab->caption);
   if(tab->cols) FREE(tab->cols);
   Amethodas(AOTP_ELEMENT,tab,AOM_DISPOSE);
}

USRFUNC_H2
(
static long  , Table_Dispatcher,
struct Table *,tab,A0,
struct Amessage *,amsg,A1
)
{
    USRFUNC_INIT
  long result=0;
   switch(amsg->method)
   {  case AOM_NEW:
         result=(long)Newtable((struct Amset *)amsg);
         break;
      case AOM_SET:
         result=Settable(tab,(struct Amset *)amsg);
         break;
      case AOM_GET:
         result=Gettable(tab,(struct Amset *)amsg);
         break;
      case AOM_MEASURE:
         result=Measuretable(tab,(struct Ammeasure *)amsg);
         break;
      case AOM_LAYOUT:
         result=Layouttable(tab,(struct Amlayout *)amsg);
         break;
      case AOM_ALIGN:
         result=Aligntable(tab,(struct Amalign *)amsg);
         break;
      case AOM_RENDER:
         result=Rendertable(tab,(struct Amrender *)amsg);
         break;
      case AOM_HITTEST:
         result=Hittesttable(tab,(struct Amhittest *)amsg);
         break;
      case AOM_MOVE:
         result=Movetable(tab,(struct Ammove *)amsg);
         break;
      case AOM_NOTIFY:
         result=Notifytable(tab,(struct Amnotify *)amsg);
         break;
      case AOM_SEARCHPOS:
         result=Searchpostable(tab,(struct Amsearch *)amsg);
         break;
      case AOM_SEARCHSET:
         result=Searchsettable(tab,(struct Amsearch *)amsg);
         break;
      case AOM_DRAGTEST:
         result=Dragtesttable(tab,(struct Amdragtest *)amsg);
         break;
      case AOM_DRAGRENDER:
         result=Dragrendertable(tab,(struct Amdragrender *)amsg);
         break;
      case AOM_DRAGCOPY:
         result=Dragcopytable(tab,(struct Amdragcopy *)amsg);
         break;
      case AOM_JSETUP:
         result=Jsetuptable(tab,(struct Amjsetup *)amsg);
         break;
      case AOM_DISPOSE:
         Disposetable(tab);
         break;
      case AOM_DEINSTALL:
         break;
      default:
         AmethodasA(AOTP_ELEMENT,(struct Aobject *)tab,amsg);
   }
   return result;

    USRFUNC_EXIT
}

/*------------------------------------------------------------------------*/

BOOL Installtable(void)
{  if(!Amethod(NULL,AOM_INSTALL,AOTP_TABLE,(Tag)Table_Dispatcher)) return FALSE;
   return TRUE;
}

BOOL Gettcellcoords(void *tc, long *tx, long *ty)
{
    if (tc)
    {
        *tx = ((struct Tabcell *)tc)->x;
        *ty = ((struct Tabcell *)tc)->y;
        return TRUE;
    }
    return FALSE;
}
BOOL Gettcellsize(void *tc, long *tw, long *th)
{
    if (tc)
    {
        *tw = ((struct Tabcell *)tc)->width;
        *th = ((struct Tabcell *)tc)->height;
        return TRUE;
    }
    return FALSE;
}
