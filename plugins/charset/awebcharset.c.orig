/**********************************************************************
 *
 * This file is part of the AWeb-II distribution
 *
 * Copyright (C) 2002 Yvon Rozijn
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the AWeb Public License as included in this
 * distribution.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * AWeb Public License for more details.
 *
 **********************************************************************/

/* awebcharset.c -  awebcharset.awebplugin source */


#include "pluginlib.h"
#include "awebcharset.h"

#include <libraries/awebsupport.h>
#include <libraries/awebmodule.h>
#include <exec/memory.h>

#undef NO_INLINE_STDARG
#define USE_INLINE_STDARG
#include <proto/awebsupport.h>
#include <proto/codesets.h>
#define NO_INLINE_STDARG

#include <proto/exec.h>
#include <stdio.h>
#include <string.h>

/* The on/off status of this plugin */
BOOL filteron;
UBYTE destname[42];
UBYTE scrname[42];

#define DEFAULTCHARSET "ISO-8859-1"

/* Actions to be performed when our library has been loaded */
ULONG Initpluginlib(struct AwebCharsetBase *base)
{
   /* Initialise platform specific environment */
   if (!AwebModuleInit()) return FALSE;

   /* Set the filter ON by default: */
   filteron=TRUE;

   /* Set the default charset */
   strncpy(destname,DEFAULTCHARSET,sizeof(DEFAULTCHARSET));

   /* Return nonzero if success */
   return TRUE;
}

/* Actions to be performed when our library is about to be expunged */
void Expungepluginlib(struct AwebCharsetBase *base)
{
   /* Cleanup platform specifics */
   AwebModuleExit();
}

/* The first library function */
LIBFUNC_H1
(
   __saveds ULONG  , Initplugin,
   struct Plugininfo *,pi,A0,
   PLUGIN_TYPE, PLUGIN_NAME
)
{
   LIBFUNC_INIT

   /* Return zero class IDs to indicate we're a filter plugin */
   pi->sourcedriver=0;
   pi->copydriver=0;

   /* Return nonzero (success) */
   return 1;

   LIBFUNC_EXIT
}

/* Query function. Handle in a safe way. There is generally no need to
 * change this code, it is generated from the #defines in pluginlib.h */

#define ISSAFE(s,f) (s->structsize>=((long)&s->f-(long)s+sizeof(s->f)))

LIBFUNC_H1
(
   __saveds void  , Queryplugin,
   struct Pluginquery *,pq,A0,
   PLUGIN_TYPE, PLUGIN_NAME

)
{
   LIBFUNC_INIT

#ifdef PLUGIN_COMMANDPLUGIN
   if(ISSAFE(pq,command)) pq->command=TRUE;
#endif
#ifdef PLUGIN_FILTERPLUGIN
   if(ISSAFE(pq,filter)) pq->filter=TRUE;
#endif

   LIBFUNC_EXIT
}

/* The command function.
 *
 * This function understand the 'On' command which
 * turn the filter on.
 *
 * If a charset (supported from the codeset.library)
 * is given as command then the filter is switched on
 * and this charset is used as destination charset.
 *
 * This function understand also the 'Off' command
 * which turn the filter off.
 *
 * If any other command is given the plugin return with
 * RC=10 and the default codeset (ISO-8859-1) is used.
*/
LIBFUNC_H1
(
   __saveds void  , Commandplugin,
   struct Plugincommand *,pc,A0,
   PLUGIN_TYPE, PLUGIN_NAME

)
{
   LIBFUNC_INIT

   STRPTR *array;
   int i=0;
   BOOL valid=FALSE;
   UBYTE buf[256];

   if(!stricmp(pc->command,"OFF"))
   {
      filteron=FALSE;
      valid=TRUE;
   }
   else if(!stricmp(pc->command,"ON"))
   {
      filteron=TRUE;
      valid=TRUE;
   }
   else if(!stricmp(pc->command,"STATUS"))
   {
      // use the MSG Strings: REQUEST_TITLE(1), ABOUT_OK(107)
      sprintf(buf,"Filter is %s\n\nScrCodeset  = '%s'\nDestCodeset = '%s'",(filteron)?"ON":"OFF",scrname,destname);
      Syncrequest(Awebstr(1),buf,Awebstr(107));
      valid=TRUE;
   }
   else if(CodesetsBase)
   {
      if((array = CodesetsSupportedA(NULL)))
      {
         for(i=0; array[i] != NULL; i++)
         {
            if(!strnicmp(pc->command,array[i],strlen(array[i])))
            {
               filteron=TRUE;
               valid=TRUE;
               strncpy(destname,array[i],sizeof(destname)-1);
            }
         }
         CodesetsFreeA(array, NULL);
      }
   }
   if (!valid)
   {
      /* Invalid command */
      pc->rc=10;

      strncpy(destname,DEFAULTCHARSET,sizeof(DEFAULTCHARSET));
   }
   LIBFUNC_EXIT
}

/* The filter function */
LIBFUNC_H1
(
   __saveds void  , Filterplugin,
   struct Pluginfilter *,pf,A0,
   PLUGIN_TYPE, PLUGIN_NAME
)
{
   LIBFUNC_INIT

   STRPTR dst;
   ULONG stringlen=0;
   UBYTE *start,*charsetname;
   UBYTE buf[42];
   BOOL valid=FALSE;
   STRPTR *array;
   int i=0;

   struct Filterdata *fd;
   struct codeset *srcCodeset, *dstCodeset;

   /* See if there is already a userdata for us.
    * If not, allocate and initialize. */
   fd=pf->userdata;
   if(!fd)
   {
      fd=Allocmem(sizeof(struct Filterdata),MEMF_CLEAR);
      if(!fd) return;
      pf->userdata=fd;
      fd->first=TRUE;
      fd->on=filteron;
   }
   if(pf->data)
   {
      if(fd->on && CodesetsBase)
      {
         if(fd->first)
         {
            strncpy(fd->destcharset,destname,sizeof(fd->destcharset)-1);

            /* look if here is a header charset */
            if(pf->encoding)
            {
               /* now look if it is supported by the codeset.library */
               if((array = CodesetsSupportedA(NULL)))
               {
                  for(i=0; array[i] != NULL; i++)
                  {
                     if(!strnicmp(pf->encoding,array[i],strlen(array[i])))
                     {
                        valid=TRUE;
                        strncpy(fd->srccharset,array[i],sizeof(fd->srccharset)-1);
                     }
                  }
               }
               CodesetsFreeA(array, NULL);
            }
            if(!valid) /* if no header charset then search for a meta 'charset=..."' */
            {
               for(start=pf->data;*start && strnicmp(start,"CHARSET=",8);start++);
               strncpy(buf,start+=8,sizeof(buf)-1);
               charsetname=strtok(buf,"\"");
               if(charsetname)
               {
                  /* now look if it is supported by the codeset.library */
                  if((array = CodesetsSupportedA(NULL)))
                  {
                     for(i=0; array[i] != NULL; i++)
                     {
                        if(!strnicmp(charsetname,array[i],strlen(array[i])))
                        {
                           valid=TRUE;
                           strncpy(fd->srccharset,array[i],sizeof(fd->srccharset)-1);
                        }
                     }
                  }
                  CodesetsFreeA(array, NULL);
               }
            }
            if(!valid) /* also no meta charset use default charset */
            {
               strncpy(fd->srccharset,DEFAULTCHARSET,sizeof(DEFAULTCHARSET));
            }
            fd->first=FALSE;
            strncpy(scrname,fd->srccharset,sizeof(scrname)-1);
         }
         if(!strnicmp(fd->srccharset,fd->destcharset,strlen(fd->srccharset)))
         {
            Writefilter(pf->handle,pf->data,pf->length);
         }
         else
         {
            srcCodeset = CodesetsFind(fd->srccharset,
                                      CSA_FallbackToDefault, FALSE,
                                      TAG_DONE);

            dstCodeset = CodesetsFind(fd->destcharset,
                                      CSA_FallbackToDefault, FALSE,
                                      TAG_DONE);

            dst = CodesetsConvertStr(CSA_SourceCodeset, srcCodeset,
                                     CSA_DestCodeset,   dstCodeset,
                                     CSA_Source,        pf->data,
                                     CSA_SourceLen,     pf->length,
                                     CSA_DestLenPtr,    &stringlen,
                                     TAG_DONE);

            Writefilter(pf->handle,dst,stringlen);
            CodesetsFreeA(dst, NULL);
         }
      }
      else
      {
         /* Don't filter data. Just write the entire block unchanged. */
         Writefilter(pf->handle,pf->data,pf->length);
      }
   }
   /* Delete our userdata when eof was reached */

   if(pf->eof)
   {
      Freemem(fd);
      pf->userdata=NULL;
   }

   LIBFUNC_EXIT
}
